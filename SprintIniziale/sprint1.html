<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
   
<title>Sprint Uno</title></head>
    
<body>
<div id="top">
<h1>LABORATORIO DI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  
<div class="body"> 
<h2>Requirements</h2>

The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tableclean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>.</li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	
 

<h2 id="ass">Requirement analysis</h2>
Tenendo a mente le considerazioni fatte nello <a href="./sprint0.html">sprint iniziale</a> 
cerchiamo di arrivare all'obiettivo lavorando in maniera <b>incrementale</b>.
Partiamo quindi considerando un caso semplificato facendo delle assunzioni:

<ul>
	<li>
		E' presente un solo cliente che richiede l'accesso alla <em>tearoom</em>, ordina, consuma, chiede di pagare e di uscire in questo ordine;
	</li>
	<li>
		Il <em>waiter</em> non viene interrotto: accetta la richiesta, accompagna il cliente, prende l'ordine, porta il drink, riscuote il pagamento, lo accompagna alla porta e pulisce il tavolo;
	</li>
	<li>
		La <em>tearoom</em> contiene due tavoli, entrambi puliti all'inizio della simulazione. <em>waiter</em> usa sempre lo stesso tavolo;
	</li>
	<li>
		All'inizio della simulazione <em>waiter</em> si trova in <em>home</em>
	</li>
	<li>
		Non scatta <em>maxstaytime</em>.
	</li>
</ul>
Date queste assunzioni, consideriamo il <em>barman</em> come attore esterno che riceverà 
un messaggio (ordine del cliente)
e risponderà, dopo un tempo (random) di preparazione, con un messaggio per indicare
che il drink è pronto.
Allo stesso modo il cliente verrà simulato come entità esterna al fine di testare
e garantire il corretto funzionamento.
</br>
</br>
Gli <b>attori</b> sono entità autonome che interagiscono tramite scambi di messaggi. Per velocizzare
il processo di modellazione adottiamo il metamodello dei <a href="https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.qakactor/userDocs/LabQakPrologUsage2020.html">QAK</a> perchè se usassimo un qualsiasi altro linguaggio di modellazione sarebbero più difficili da rappresentare.
Invece, il <b>tavolo</b> verrà modellato come un oggetto.
</br>
</br>
Essendo stato introdotto e scelto il modello QAK non parleremo più di messaggi ma di <b>Dispatch</b>, <b>Request</b>-<b>Reply</b> e <b>Event</b>.
Ridefiniamo i messaggi individuati nello sprint iniziale traducendoli nella <b>semantica</b> del modello QAK:
</br>
</br>
<table>
	<thead>
		<tr>
			<th class="tg-0lax">nome messaggio</th>
			<th class="tg-0lax">QAK</th>
			<th class="tg-0lax">motivazione/scelta</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="tg-0lax"><em>clientEntryRequest</em></td>
			<td class="tg-0lax">Request</td>
			<td class="tg-0lax">Sarebbe giusto notificare il desiderio di un cliente di entrare a tutti i <em>waiter</em> tramite Event. Questo porterebbe problemi di interazione/organizzazione tra i vari <em>waiter</em> e avendone noi uno solo è più semplice pensare a una tipologia di messaggio point-to-point di tipo Request-Reply o Dispatch. Dovendo però il cliente ricevere una risposta, scegliamo di adottare una Request-Reply.</td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>waiterEntryReply</em></td>
			<td class="tg-0lax">Reply</td>
			<td class="tg-0lax">Aspettandosi il cliente una risposta questo fortifica la scelta appena fatta.</td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>clientOrderReady</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">No Event per motivo <em>clientEntryRequest</em>. Non si prevede una risposta quindi adottiamo un Dispatch. </td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>waiterOrderForward</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">Per gli stessi motivi di <em>clientOrderReady</em> (c'è un solo <em>barman</em>)</td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>barmanOrderReady</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">Per gli stessi motivi di <em>clientOrderReady</em></td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>clientPaymentReady</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">Per gli stessi motivi di <em>clientOrderReady</em></td>
		</tr>
	</tbody>
</table>
</br>
Dalle assunzioni fatte notiamo che il task <em>inform</em> non è da modellare, in quanto essendoci solo un cliente ed entrambi i tavoli sono puliti si avrà sempre un posto disponibile.</br>
Proseguiamo quindi con la modellazione dei due agenti che compongono il waiter tramite grafi degli stati.
</br>
<!--Grafo ENGINE-->
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2020-07-01T14:21:33.755Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\&quot; etag=\&quot;DWnHhTsUBkdLeFMWrY2c\&quot; version=\&quot;13.3.5\&quot;&gt;&lt;diagram id=\&quot;2zA2yLJ3x4JN4bZLVGS_\&quot; name=\&quot;Page-1\&quot;&gt;7Vtbc5s4FP41ntl9cAZxs/NY23E67XqbWWe2zdOOYgRmKxAF+dZfXwGyuQhj7BijnU0eEnSQhHT0ne8cHSk9bextH0MYLGfEQrinKta2p016qnqvq+x3LNilAjBQuMQJXYvLMsHc/Ym4UOHSlWuhqFCREoKpGxSFC+L7aEELMhiGZFOsZhNc/GoAHSQI5guIRelX16LLVDpUB5n8I3Kd5f7LwLxP33hwX5nPJFpCi2xyIu2hp41DQmj65G3HCMfK2+slbTc98vYwsBD5tEkD+2s0c7y/LHP7N3wBn5/61vdhnw92DfGKT7inmpj1N4oC6MejpjuuCvPHKh7qaEEwCXvaB/YydF5/GzBNsA+P2e8hyB7N3+NnbZTo3Kd9G3ou3qXNWF/QC5KXmqazvzB0IRakh84i6Ef9CIWuXewzStAS9wj0YHt4R9GW9iF2HT99iZFNs+GzJyf5O37ojYz9bJna0gmnL/seX7PD7FVkMVzwIgnpkjjEh/ghk45CsvItFGs7HkhW5w9C2LQmgAn/RZTuOMjhihImWlIP87do69JvueeXuKs7g5cmW95zUtjtCz4Nd9/yhVyruJg1S0pZO+tDbB7xbALkp5KpizF/L6KLAy4iq3CBaiC1t1IYOojW1OM8EOs19wGO3UdEPMTGG4MMYUjdddEeITdr51AvQz574OA/wxCAYAiRImAgW+F4iTZLl6J5ABNtbBj9FVfTZsocp7bC2mpj9jOd1ml2jUIG3Vpd8LcDPjROqiYvbjKCAnvWWebIaV/v6sobCMpbYBRbkyw2pF5mRGp3VqQ2tCJTLitSBCR4ZI2eSZdQUO4GRg4N4CIoyI8EoyESOIcodzowueE2Bgfv7Ym4bBZZFWLbERtbGT2HjzYC1PfF9Mvr4vP9i/XpZTp5Xv7Ef/6zn3wOT0yt3YIpjyWlIZYy+BwQWIOles9RWuCrgapS/52yibj4G+jSsScCQBbHrA6788yP9uTJmgZPkT6bOZ/mP76MvKgPRB1GFAUW8VGnVlTwzoOG3hn0CpQ8OMXJl5uHJppHtXqv7X2TpsyRwF2uQhDTbVTBvxx1ulpEnTY08sA5Wd8ARglo6QguZfJqVWmVSLShi5FEjF4fHVwVUdURlFwBnbhoaIsWc7Zw0nKwAUrWoHe9Paog4Z4xoiErGJMuoQ8uomF5Nkl6Q6PSpLIpoFfBwYY46hoPRbd8Cg71q3rMa7fntCvQUOmJrp54OuJl9SIPqfclfkkHylu9aetUp44cykIELampWysFJqrROXWLecH3BHmv6wT5OSHbsU24coKH2vNaRkOvpUuxuTDMkk1qSsmq3rZZqFNRzuoCDP2n+EhNVu4ylKKeQOfcNTxKXZa7rmSuhsRwQwLkPRb57zCeM+nvLIaTepbHliT+ROVgy/oAVfqISf2gi7SrYvdHVPQaVlRMMLaXyhLStpVpOuUsMHxFeAQX351kYjkKspOfOgpqPU69vy8Sl2IUu0gdmhCnCh1ppzpqOeA1Bb5LTiGf4SsWk52yuo3Oz3KB6HvfI97uI942dub53E2Tc6nLQ17QNP15o725VtqbA63Z3vzc4Ll8UcMoXdGqrw6G9dU1UFu/ndC8Io/P4CV1aF5OK5jqDUm2MgVVce1OwoTwZcHSyXzwG2jEbEgjTbfOHCB9NmqNt2l3Nz0wilDcu/+jjFCqzyjkuIm3dDGj+jhPvOkjSxL7suTQ4Kzs0A0wDDo7tahccPGO3397vdXrr3fdFYHrLXfGWYqpGpeQ1i15oiIJJaGna3w/tI2I+U2wOdPTKXe6OjRlB4146LIKLEjRDMp7dgVKQaY+6DrIVAUtxnc3ZmQtbzakrMSb3t2oVGLFWf17Ev09if4/S6JLcN76lhT6SW+rit72hvc9xTNXpZRJBxem5PVTHbWckgdiTh6xRQ4/Qt/CKJTWD5XvEN7UmR+/iF/Ous0pC4raVKKgsQq9HlVi+TJ8v8UTcVbM/pM2RW/2/8jawy8=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
<script type="text/javascript" src="https://app.diagrams.net/js/viewer.min.js"></script>
</br>
<em>Engine:</em>
Componente che pulisce il tavolo e gestisce il movimento del <em>waiter</em>. L'idea è che <em>Engine</em> ottenga una successione di step da eseguire al fine di attuare il movimento richiesto e che si interfacci con un'altra entità per l'esecuzione di ogni step. 
<em>Engine</em> viene attivato da <em>Mind</em> e come ultima istruzione del suo stato iniziale &lt;s0&gt; invia a <em>Mind</em> una dispatch <u>engineReady</u>.
A partire dallo stato &lt;waitCmd&gt; si possono seguire tre sequenze di transizioni, innescate da 3 messaggi diversi:
<ul>
	<li>
		<u>end</u>, provoca la terminazione di <em>Engine</em> 
	</li>
	<li>
		<u>clean</u>, contiene un parametro che specifica il tipo di pulizia da eseguire. Per rendere un tavolo di nuovo usufruibile da un cliente, <em>Engine</em> dovrà ricevere 3 messaggi <u>clean</u>, ogni volta con parametro diverso, in questo ordine: clear, sanitize e clean.
	</li>
	<li>
		<u>moveTo</u>: contiene un parametro che esprime la posizione (x,y) che si vuole raggiungere nella <em>tearoom</em>. In &lt;planPath&gt; si ottiene la lista di step da eseguire da un'entità esterna e poi vengono eseguiti uno ad uno. Nello stato &lt;readStep&gt; si controlla se lo step può ritornare errore e si transita di conseguenza in uno stato che esegue lo step (&lt;execStep&gt; o &lt;execMove&gt;). Poi si passa in uno stato dove si aggiorna lo stato della <em>tearoom</em> indicando la nuova posizione del <em>waiter</em> e si controlla se sono rimasti step da fare. Se sì <em>Engine</em> torna a &lt;readStep&gt; altrimenti passa a &lt;endPath&gt;
	</li>
</ul>
<!--
 poi si porta nello stato &lt;waitCmd&gt;, nel quale attende uno tra tre messaggi possibili, tutti provenienti da Mind. Uno di questi messaggi è <u>end</u>, che provoca la transizione verso lo stato &lt;terminate&gt; nel quale <em>Engine</em> termina la sua esecuzione. I restanti due messaggi provocano due sequenze di transizioni distinte che alla fine riportano allo stato &lt;waitCmd&gt;. Le due sequenze rappresentano la suddivisione in passi elementari dei due compiti di <em>Engine</em>. I due messaggi sono:
<ul>
	<li>
		<u>moveTo</u>: contiene un parametro che esprime la posizione (x,y) che si vuole raggiungere nella <em>tearoom</em>. Provoca la transizione verso &lt;planPath&gt; in cui si ottiene una successione ordinata di step da eseguire, la quale dovrà essere mantenuta in uno scope visibile anche dai prossimi stati della sequenza. Successivamente si transita nello stato &lt;readStep&gt; dove si controlla che tipo di step va fatto: BasicRobot permette di compiere un passo in avanti o indietro e di ruotare su se stessi verso destra o verso sinistra. Le rotazioni non ritornano mai errore mentre i passi possono farlo, quindi usiamo due stati per differenziare la gestione dei due casi. Inoltre non ha senso che la successione ordinata di step comprenda dei passi all'indietro, quindi l'unico caso che può ritornare un errore è il passo in avanti. Per questo motivo nello stato &lt;readStep&gt; basta controllare se devo fare un passo in avanti. 
		In caso negativo si transita nello stato &lt;execMove&gt;, dove si comunica a BasicRobot di compiere lo step e si transita in &lt;updateMap&gt;, dove si aggiorna la mappa indicando il nuovo stato del <em>waiter</em>.
		In caso positivo si transita nello stato &lt;execStep&gt;, dove si comunica a BasicRobot di compiere il passo in avanti e si attende una risposta. Se lo step ha successo si transita in &lt;updateMap&gt;, altrimenti in &lt;errorHandler&gt;, dove si effettua una piccola correzione per compensare lo step fallito.
		Le transizioni di uscita da &lt;updateMap&gt; e &lt;errorHandler&gt; sono identiche: si controlla se sono rimasti step da compiere nella successione ordinata.
		In caso negativo si transita nello stato &lt;endPath&gt;, nel quale si manda a <em>Mind</em> un messaggio di conferma <u>done</u> e poi si ritorna a &lt;waitCmd&gt;. In caso positivo <em>Engine</em> si riporta nello stato &lt;readStep&gt;.
	</li>
	<li>
		<u>clean</u>: contiene un parametro che specifica quale tipo di pulizia effettuare (clear, sanitize o clean). Qualunque sia il valore del parametro, <em>Engine</em> transita nello stato &lt;cleanTable&gt; per effettuare la pulizia richiesta. A lavoro ultimato ritorna a &lt;waitCmd&gt;. Per rendere un tavolo di nuovo usufruibile da un cliente, <em>Engine</em> dovrà ricevere 3 messaggi <u>clean</u>, ogni volta con parametro diverso, seguendo l'ordine descritto.
	</li>
</ul> 
-->
</br>
</br>
<!--Grafo MIND-->
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2020-07-02T12:12:07.769Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\&quot; etag=\&quot;frkQxSMeZD32jfKm3_xd\&quot; version=\&quot;13.3.5\&quot;&gt;&lt;diagram id=\&quot;cU18ib_VpRdZYBQb-qZ6\&quot; name=\&quot;Page-1\&quot;&gt;7Vxbc9soFP41mtk+uKOrL4+J67TbabfZujPbPhIJ23SxUBGO7f31CxK6Iruy41hoxnlIJC4HdPi+w+EAMZzpeveegmj1mQQQG7YZ7AznnWHbE9fmv0XCPk3wxjJhSVGQJllFwhz9B2WiKVM3KIBxpSAjBDMUVRN9EobQZ5U0QCnZVostCK62GoElVBLmPsBq6j8oYKs0dWyPivQPEC1XWcvWcJLmrEFWWH5JvAIB2ZaSnJnhTCkhLH1a76YQC91leknrPRzIzTtGYcjaVPj09193Xz6s2e7zJn7czkeLj/RuYI9TMc8Ab+QXG/YQc4H3AXoWvWZ7qYrhr43o6j2DOzYAGC1Dw7njJTBcsCKXPy3l30TKgvDecb0DvyoFUAR476aiCRDGgxhStFDFwHCJQvgVAo4fKZF/YSq02hBPTnqcpdqVztsw4MMqXwllK7IkIcCzIvWekk0YQKEsk78VZT4REvFEiyf+hIztJUbBhhGetGJrLHPhDrHvpecfQtRbT76920nJycs+ewkZ3X8vv5RqideiWvKW1cPgCeJ74P+7TLo9JZjQ5EOdRfKTVAjuBAHEB0cwTFMeEMZShIofCamYbKgcrQOgkTwEdAnZkXKSCUL1pQYkOt9Dsob8k3gBCjFg6LnKOCCJu8zLFdjmDxLep0BdQXrMv4DNGWBQgUsBBjGa2xVicB6lGN5yO1cd+AVXamkEpvzn4eGYhp8h5Sw6qhNpLi1PWo9tYXyszKKsSoZnaL6W2lS9ZZSLIxA2mgg/VYawDnT59MeIG0sz5frYKh6Hb8SzUJMpCD1YgDXC+7QalwXWQs1Vc1FNzEWVLUhZYpxQVciz3GiX57W0YNOZce+VzEv6uWnmYN0fC3PcDLSwJOdbCufSFkBWfSQomVZ2OSMk/CVtXLtGh9RWyWoFI7hmwL5ULBIF4sMNTVynsZ2CYKnEgm75R57PQEchIKMc8GvE9DNbMnfkVsfDmXRtxizV0QlIqBp+bVl8np/wek6A29IJuLgJeBEMXAUFFAJ/9Q08YfiFBpBqSynP0o1StmqYbpR6CaW8lpSy9HKsvWZOcZ+tN2TK37ubn1TL1BmZcmIUXPhRzjuTGBlJC2LmUg+StBWZvo//9H6CRzAD4dwzof3xCUWtF6nZKP+WTBI6A/PtxB3LXrzUbx3X3FarnduqCsrXiVKS7dUkpfp6sQOseNrDetSpVsEeHy1f9ZiL2ll/yGIRQ2bU2XUBr9pVzVa/Zq/XmoWGl55cWiLJaQn+SwFgqIy/T8Jnsk98QW1nrkltZZXzq7uZ6+YGXpaAo5Yz18WJ+iIYjJq9wHeE6OsG1sMUGpCp22gr16/jKuHWLNW4xVu7nJjHLe3CSCu7oMbdgO/DSN/YZX1tqIFRUG2rjxH/wiRiJTdH+8IO3WbbSUtWuS1ZJVFkvh0Oh3LcTvOUT12SOaMqXrNF5aEVWb380T2Ma67IbHVF9gToGoQ3mF8P5t6pMOc+VC9g7rm6wPyQNZ8JKHyFvzYwVmfHG9AvDPTxqUD33LHbB6BncZTOge5YCtD5IHeJ7Grk2WyJ7MtGwV8f2U7biPZ1FgCOuqRN7d0j2K/5n9vEfhVU2G03DXODx5c+9jkG75o2ZqJgizbNnrqsLfPDwPoc71PD4P2K3nZ4uu3y+/Att0oyX/ZaWyWWSrMY0meo91ZJPbrb/Sa/rXpEXZOt3y5RNnp9O4puNkxbwF994PK1pVN97nLMrunk6Hems+d0ar3E0GuPwW5yA7NjnZwOWNwM05VX9f2G7n1CRzVPHGGaXpQ5YJ3srpXoqgf6DOFsi/BMsulZejxpf1fuwWZ/3hjNe7oriJ8hQz4wGvdnrWhXzkgbFTkhoWuAS3lbqS2R6ZpySxdzawjpgPfZR+FSrVnf8vX5yEJaykMcNaGUamZ9SXKSyw0LLiuTGsI0d0toUG0xr/iUe/iDmrZsz0sVVX6QOgtQHGEg9YVCjLKWFpgAVmu+vl0tZpophiD8ugkPbFofGu++LK10C3U4TsvpydXr0oHTcINHzExzECKG/hNw1tWsTrQzq2o0scrEm+93JrlaX+jRjFzqPJuQSyCC9ola3ft9rn7hiZ5PWG1v9DhtT5dciVMHrvR8y4il2lldWDUytWOVuprqmlWn3MB5RXYM27Kj7aGUK7Hj0M2B2U7nK9mmZp6cowZtbkedjX4dddZuwm17d8LR6/KE03AmrGdhy87tiXtglZ34KzovBCyrfg3liqo8dne2pMlNFAAGC/+Pq6036ryqC9ioz+arpvrFLH7nCTbHLMzOzL3bEBA8BujXPqgxmdSQV0fUgVvYvxU0qck5+7wHfy3+42BavPi3jc7sfw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
<script type="text/javascript" src="https://app.diagrams.net/js/viewer.min.js"></script>
</br>
<em>Mind:</em>
Componente di <em>waiter</em> che mantiene il controllo sul task in esecuzione. Nello sviluppo del grafo degli stati si è mantenuto l'approccio per sequenze di transizioni per cui ogni sequenza rappresenta un compito dell'agente. Nel caso di <em>Mind</em> una sequenza rappresenta un task (o gruppi di task). Lo stato &lt;rest&gt; è molto simile al &lt;waitCmd&gt; di <em>Engine</em>, in quanto è punto di partenza delle sequenze di transizioni. Le transizioni terminano in &lt;reachHome&gt;</br>
Tutti gli stati di <em>Mind</em> che hanno nome con prefisso "reach", "convoy" o "serve" implicano uno spostamento del <em>waiter</em> e quindi l'invio a <em>Engine</em> di una request <u>moveTo</u>. Per questo motivo la transizione di uscita da questi stati è innescata da una reply <u>done</u> proveniente da <em>Engine</em>, che indica il completamento dello spostamento.</br>
Gli stati "reach" rappresentano un movimento in cui il <em>waiter</em> è da solo. Negli stati "convoy" il <em>waiter</em> accompagna il cliente a destinazione, mentre nello stato "serve" il <em>waiter</em> porta con sé un drink. Si noti anche che ogni stato di movimento specifica il motivo per cui ci si deve spostare verso la destinazione: ad esempio &lt;reachTableCollect&gt;, &lt;reachTableClean&gt;, &lt;convoyTable&gt;, &lt;reachTableOrder&gt; e &lt;serveTable&gt; rappresentano tutti movimenti verso il tavolo ma il compito del <em>waiter</em> una volta raggiunto il tavolo cambia da stato a stato. </br>
Ci sono 3 dispatch e 1 request che provocano altrettante sequenze distinte di transizioni:
<ul>
	<li>
		<u>clientEntryRequest</u> : request inviata dal cliente, indica che il cliente vuole entrare nella <em>tearoom</em>. Al suo interno contiene un parametro che specifica l'id del cliente. La sequenza termina quando il cliente è stato portato al tavolo. Stando alle <a href="#ass">assunzioni</a> il controllo sulla condizione dei tavoli ritorna sempre che c'è un tavolo libero, quindi si ha una transizione automatica da &lt;accept&gt; a &lt;reachDoor&gt;, 
	</li>
	<li>
		<u>clientOrderReady</u>: dispatch inviata dal cliente, indica che il cliente è pronto per ordinare. La sequenza termina con la trasmissione dell'ordine a <em>barman</em>. Dato che <em>waiter</em> usa sempre lo stesso tavolo, secondo le <a href="#ass">assunzioni</a> di questo sprint la dispatch non contiene parametri. In futuro potrebbe essere opportuno inserire l'id del cliente o il numero di tavolo.
	</li>
	<li>
		<u>barmanOrderReady</u>: dispatch inviata da <em>barman</em>, indica che il drink è pronto. Come per il caso precedente non contiene parametri ma in futuro potra essere opportuno aggiungerne. La sequenza termina quando il <em>waiter</em> ha portato il drink al tavolo. 
	</li>
	<li>
		<u>clientPaymentReady</u>: dispatch inviata da cliente, indica che il cliente vuole pagare e uscire. Subito dopo averlo accompagnato alla porta di uscita <em>waiter</em> comincia a pulire il tavolo usato. La sequenza termina quando il tavolo è di nuovo pulito.
	</li>
</ul>

<!--
Al momento dell'avvio del <em>waiter</em> si avvia <em>Mind</em> che parte dallo stato &lt;init&gt;, nel quale si avvia <em>Engine</em> e, in accordo con le <a href="#ass">assunzioni</a>, si passa direttamente allo stato &lt;rest&gt; non appena <em>Engine</em> invia un <u>engineReady</u>. Lo stato &lt;rest&gt; è molto simile al &lt;waitCmd&gt; di Engine, in quanto è punto di partenza delle sequenze di transizioni. Le sequenze terminano nello stato &lt;reachHome&gt;, che provoca lo spostamento del <em>waiter</em> verso <em>home</em> e poi la transizione verso &lt;rest&gt;. Tutti gli stati di <em>Mind</em> che hanno nome con prefisso "reach" o "convoy" implicano uno spostamento del <em>waiter</em> e quindi l'invio a <em>Engine</em> di un messaggio <u>moveTo</u>. Per questo motivo la transizione di uscita da questi stati è innescata da un messaggio <u>done</u> proveniente da <em>Engine</em>, che indica il completamento dello spostamento.</br>
Oltre al messaggio <u>end</u>, che provoca la transizione in &lt;terminate&gt;, e quindi il forward di <u>end</u> verso <em>Engine</em> e lo spegnimento di <em>Mind</em>, ci sono 4 messaggi che provocano altrettante sequenze distinte di transizioni:
<ul>
	<li>
		<u>clientEntryRequest</u> : inviato dal cliente, indica che il cliente vuole entrare nella <em>tearoom</em> e provoca la transizione verso &lt;accept&gt;. Stando alle <a href="#ass">assunzioni</a> il controllo sulla condizione dei tavoli che <em>Mind</em> esegue in questo stato ritorna sempre che c'è un tavolo libero, quindi si ha una transizione automatica da &lt;accept&gt; a &lt;reachDoor&gt;, in cui <em>waiter</em> raggiunge la porta di ingresso della <em>tearoom</em>. Una volta giunti a destinazione <em>Mind</em> transita nello stato &lt;convoyTable&gt; in cui accompagna il cliente ad un tavolo libero.
	</li>
	<li>
		<u>clientOrderReady</u>: inviato dal cliente, indica che il cliente è pronto per ordinare e provoca la transizione verso &lt;reachTableOrder&gt; in cui <em>waiter</em> raggiunge il tavolo del cliente. Una volta giunto il messaggio <u>done</u> di conferma del movimento, <em>Mind</em> transita verso &lt;transmit&gt;
	</li>
	<li>

	</li>
	<li>
	</li>
</ul> 

</br>
</br>

-->
<h2>Problem analysis</h2>
Dall'analisi emersa dallo <a href="./sprint0.html">sprint precedente</a>, si nota che la maggior parte dei task per funzionare hanno bisogno del movimento.
Per questo motivo viene introdotta un'entità esterna detta <em>planner</em>.
Il suo compito è quello di far raggiungere al <em>waiter</em> la posizione desiderata nella <em>teamroom</em>. Per far ciò è necessario che il <em>planner</em> 
conosca la mappa della stanza a priori.
</br>
La mappa viene creata dal <em>planner</em> utilizzando <em>boundarywalker</em> e <em>mappingwalker</em> che esplorano l'ambiente creano un file JSON/XML. Essa deve essere interpretata nel seguente modo:

<ul>
<li><b>r:</b> cella occupata dal robot;</li>
<li><b>1:</b> cella esplorata dal robot;</li>
<li><b>0:</b> cella non ancora esplorata;</li>
<li><b>X:</b> cella che contiene un ostacolo.</li>
</ul>

Inoltre, la mappa <b>non</b> presenta ostacoli mobili ma solo fissi per cui non serve che sia riconfigurata ogni volta nel <em>planner</em>.
Il <em>planner</em> vede la <em>tearoom</em> come un insieme di celle della dimensione del robot ognuna delle quali è caratterizzata da un punto bidimensionale XY.
<br/>
Chiamiamo con il termine <b>step</b> l'unità dello spostamento del <em>waiter</em> da una cella ad un'altra adiacente, corrispondente alla lunghezza del robot.

Le posizioni che devono essere raggiunte dal <em>waiter</em> sono inserite in un <b>file</b> di configurazione <b>JSON</b>.
<br/>
Tuttavia, i veri spostamenti vengono effettuati dal <a href="https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.qak20.robotboundary/userDocs/Qak20Robotboundary.html">basicrobot</a>: il <b>mind</b> chiede uno spostamento all'<b>engine</b> che a sua volta inoltra la richiesta al basicbot.
</br>
</br>
Sempre facendo riferimento alle <a href="./sprint0.html">assunzioni</a> già fatte, è opportuno modellare lo stato del tavolo all'interno dell'entità che tiene tutti gli stati della <em>teamroom</em>.
Per una prima e veloce modellazione tralasciamo questa entità e inseriamo gli stati dei tavoli all'interno del <b>mind</b>.
</br>
</br>
Siamo già in grado di mostrare un primo <b>prototipo</b> al committente grazie all'ausilio di un <a href="https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.virtualRobot2020/userDocs/LabVirtualRobot.html">robot virtuale</a>.
</br>
</br>
Dunque, per collegare <b>engine</b> e <b>mind</b> vengono introdotti nuovi messaggi:

- moveTo(X,Y): il mind lo manda all'engine per spostarsi alla cella X,Y. E' modellato con una Request in modo tale che il mind in seguito riceva la risposta da parte dell'engine;
- done(X,Y): è modellato come Reply e viene mandato dall'engine al mind come risposta per indicare se ha raggiunto la cella;
- start: il mind lo manda all'engine per sapere se è pronto per ricevere i messaggi. E' modellato come Request;
- ready: l'engine lo manda al mind per dire che è pronto a ricevere i messaggi. E' modellato come Reply 

<pre>
test
</pre>

<h2>Test plans</h2> 
<div class="remark">
<ks>GOAL</ks>: give a formal description (for example, by using <ks>JUnit</ks>) of the <k>functional TestPlans</k>, with reference to the <k>logical architecture</k> of the system .
</div>

<h2>Workplan</h2> 
 


<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By studentName email: student@studio.unibo.it  
<img src="./img/emiglio.png" alt="mbot" width="15%" height="15%">
</div> 
</body>
</html>