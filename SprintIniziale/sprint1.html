<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<head>
   
<title>Sprint Uno</title></head>
    
<body>
<div id="top">
<h1>LABORATORIO DI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Requirements</h2>

The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tableclean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>.</li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	
 

<h2>Requirement analysis</h2>
Tenendo a mente le considerazioni fatte nello <a href="./sprint0.html">sprint iniziale</a> 
cerchiamo di arrivare all'obiettivo lavorando in maniera <b>incrementale</b>.
Partiamo quindi considerando un caso semplificato facendo delle assunzioni:

<ul>
<li>E' presente un solo cliente che richiede l'accesso alla <em>teamroom</em>, ordina, consuma, chiede di pagare e di uscire;</li>
<li>Il <em>waiter</em> non viene interrotto: accetta la richiesta, accompagna il cliente, prende l'ordine, porta il drink, riscuote il pagamento, lo accompagna alla porta
e pulisce il tavolo;</li>
<li>Non scatta <em>maxstaytime</em>.</li>
</ul>
Date queste assunzioni, consideriamo il <em>barman</em> come attore esterno che riceverà 
un messaggio (ordine del cliente)
e risponderà, dopo un tempo (random) di preparazione, con un messaggio per indicare
che il drink è pronto.
Allo stesso modo il cliente verrà simulato come entità esterna al fine di testare
e garantire il corretto funzionamento.
</br>
</br>
Gli <b>attori</b> sono entità autonome che interagiscono tramite scambi di messaggi. Per velocizzare
il processo di modellazione adottiamo il metamodello dei <a href="https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.qakactor/userDocs/LabQakPrologUsage2020.html">QAK</a> perchè se usassimo un qualsiasi altro linguaggio di modellazione sarebbero più difficili da rappresentare.
Invece, il <b>tavolo</b> verrà modellato come un oggetto.
</br>
</br>
Essendo stato introdotto e scelto il modello QAK non parleremo più di messaggi ma di <b>Dispatch</b>, <b>Request</b>-<b>Reply</b> e <b>Event</b>.
Ridefiniamo i messaggi individuati nello sprint iniziale traducendoli nella <b>semantica</b> del modello QAK:
</br>
</br>
<table>
	<thead>
		<tr>
			<th class="tg-0lax">nome messaggio</th>
			<th class="tg-0lax">QAK</th>
			<th class="tg-0lax">motivazione/scelta</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="tg-0lax"><em>clientEntryRequest</em></td>
			<td class="tg-0lax">Request</td>
			<td class="tg-0lax">Sarebbe giusto notificare il desiderio di un cliente di entrare a tutti i <em>waiter</em> tramite Event. Questo porterebbe problemi di interazione/organizzazione tra i vari <em>waiter</em> e avendone noi uno solo è più semplice pensare a una tipologia di messaggio point-to-point di tipo Request-Reply o Dispatch. Dovendo però il cliente ricevere una risposta, scegliamo di adottare una Request-Reply.</td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>waiterEntryReply</em></td>
			<td class="tg-0lax">Reply</td>
			<td class="tg-0lax">Aspettandosi il cliente una risposta questo fortifica la scelta appena fatta.</td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>clientOrderReady</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">No Event per motivo <em>clientEntryRequest</em>. Non si prevede una risposta quindi adottiamo un Dispatch. </td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>waiterOrderForward</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">Per gli stessi motivi di <em>clientOrderReady</em> (c'è un solo <em>barman</em>)</td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>barmanOrderReady</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">Per gli stessi motivi di <em>clientOrderReady</em></td>
		</tr>
		<tr>
			<td class="tg-0lax"><em>clientPaymentReady</em></td>
			<td class="tg-0lax">Dispatch</td>
			<td class="tg-0lax">Per gli stessi motivi di <em>clientOrderReady</em></td>
		</tr>
	</tbody>
</table>
</br>
Dalle assunzioni fatte notiamo che il task <em>inform</em> non è da modellare, in quanto essendoci 
solo un cliente e entrambi i tavoli puliti non potrà mai verificarsi.
</br>
</br>
<img src="./img/mind.png" alt="fsm" width="80%" height="80%">
</br>
</br>
<img src="./img/engine.png" alt="fsm" width="80%" height="80%">


<h2>Problem analysis</h2>
Dall'analisi emersa dallo <a href="">sprint precedente</a> , si nota che la maggior parte dei task per funzionare hanno bisogno del movimento. Per questo motivo viene introdotta un'entità esterna detta <em>planner</em>.
Il suo compito è quello di far raggiungere al waiter la posizione desiderata nella teamroom. Per far ciò è necessario che il planner conosca la mappa della stanza a priori.
La mappa <b>non</b> presenta ostacoli mobili ma solo fissi per cui non serve che sia riconfigurata ogni volta nel planner.
Il planner vede la tearoom come un insieme di celle ognuna delle quali è caratterizzata da un punto bidimensionale XY e chiamiamo con il termine <b>step</b> l'unità di misura del 
movimento cioè lo spostamento del waiter da una cella ad un'altra.

Dunque, per collegare <b>engine</b> e <b>mind</b> vengono introdotti nuovi messaggi:

- move(X,Y): il mind lo manda all'engine per spostarsi alla cella X,Y. E' modellato con una Request in modo tale che il mind in seguito riceva la risposta da parte dell'engine;
- done(X,Y): è modellato come Reply e viene mandato dall'engine al mind come risposta per indicare se ha raggiunto la cella;
- start: il mind lo manda all'engine per sapere se è pronto per ricevere i messaggi. E' modellato come Request;
- ready: l'engine lo manda al mind per dire che è pronto a ricevere i messaggi. E' modellato come Reply 

I veri spostamenti vengono effettuati dal <a href="">basicrobot</a> che oltre ad essere un attuatore è anche un sensore per rileveare eventuali ostacoli.

Sempre facendo riferimento alle <a href="">assunzioni</a> già fatte, è opportuno modellare lo stato del tavolo all'interno dell'entità che tiene tutti gli stati della teamroom.
Per ora lo teniamo all'interno del waiter mind.

Siamo già in grado di mostrare un primo prototipo al committente grazie all'ausilio di un <a href="">robot virtuale<a>.

entità stato totale mappa che memorizza e ritorna

<pre>
test
</pre>

<h2>Test plans</h2> 
<div class="remark">
<ks>GOAL</ks>: give a formal description (for example, by using <ks>JUnit</ks>) of the <k>functional TestPlans</k>, with reference to the <k>logical architecture</k> of the system .
</div>

<h2>Workplan</h2> 
 


<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By studentName email: student@studio.unibo.it  
<img src="./img/emiglio.png" alt="mbot" width="15%" height="15%">
</div> 
</body>
</html>