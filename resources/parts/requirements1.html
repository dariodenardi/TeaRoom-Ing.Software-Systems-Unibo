<html>
<head>
	<link rel="stylesheet" type="text/css" href="../style/style.css">
	
	<script>
		function openInNewTab(url) {
			var win = window.open(url, '_blank');
			win.focus();
		}
	</script>
</head>
<body>
	<div class=body>
		Partiamo considerando un caso semplificato facendo delle assunzioni:

		<ul>
			<li>
				E' presente un solo <em>client</em> che richiede l'accesso alla <em>tearoom</em>, ordina, consuma, chiede di pagare e di uscire in questo ordine;
			</li>
			<li>
				Il <em>waiter</em> non viene interrotto: accetta la richiesta, accompagna il <em>client</em>, prende l'ordine, porta il drink, riscuote il pagamento, lo accompagna alla porta e pulisce il <em>table</em>;
			</li>
			<li>
				La <em>tearoom</em> contiene due <em>table</em>, entrambi puliti all'inizio della simulazione. <em>waiter</em> usa sempre lo stesso <em>table</em>;
			</li>
			<li>
				All'inizio della simulazione <em>waiter</em> si trova in <em>home</em>
			</li>
			<li>
				<em>maxstaytime</em> e la <em>hall</em> non vengono considerati.
			</li>
		</ul>
		Riprendiamo la tabella dei task dello sprint iniziale e cerchiamo eventuali task che possiamo ignorare date le assunzioni:
		<br/>
		<br/>
		<table>
				<thead>
					<tr>
						<th>nome task</th>
						<th>cosa fa</th>
						<th>tempo qualitativo</th>
						<th>tempo quantitativo</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><em>accept</em></td>
						<td>conferma la richiesta del <em>client</em> se è presente un <em>table</em> nello stato <em>tableclean</em></td>
						<td>poco</td>
						<td>2s</td>
					</tr>
					<tr>
						<td><em>inform</em></td>
						<td>informa il <em>client</em> sul tempo massimo di attesa <em>maxwaittime</em> nel caso non sia possibile eseguire il task <em>accept</em>  <br></td>
						<td>poco</td>
						<td>2s</td>
					</tr>
					<tr>
						<td><em>reach</em></td>
						<td>raggiunge la porta di ingresso e accompagna il <em>client</em> (accettato) al <em>table</em> selezionato</td>
						<td>alto<br></td>
						<td>60s</td>
					</tr>
					<tr>
						<td><em>take</em></td>
						<td>va al <em>table</em> del <em>client</em>, prende l'ordine e lo trasmette al <em>barman</em></td>
						<td>poco</td>
						<td>8s</td>
					</tr>
					<tr>
						<td><em>serve</em></td>
						<td>quando il <em>barman</em> dice che la bevanda è pronta va a prenderla e la porta al <em>client</em> che l'aveva richiesta</td>
						<td>medio</td>
						<td>30s</td>
					</tr>
					<tr>
						<td><em>collect</em></td>
						<td>va al <em>table</em> del <em>client</em> per riscuotere il pagamento</td>
						<td>poco</td>
						<td>8s<br></td>
					</tr>
					<tr>
						<td><em>convoy</em></td>
						<td>accompagna il <em>client</em> alla porta</td>
						<td>medio</td>
						<td>30s</td>
					</tr>
					<tr>
						<td><em>clean</em></td>
						<td>pulisce il <em>table</em></td>
						<td>medio</td>
						<td>45s</td>
					</tr>
					<tr>
						<td><em>rest</em></td>
						<td>va in home se non c'è niente da fare</td>
						<td>medio/alto<br></td>
						<td>variabile</td>
					</tr>
				</tbody>
			</table>
		</br>
		Dalle assunzioni fatte notiamo che il task <em>inform</em> non è da modellare, in quanto essendoci solo un <em>client</em> ed entrambi i <em>table</em> sono puliti si avrà sempre un posto disponibile.
		</br>
		</br>
		Essendo stato introdotto e scelto il modello QAK vediamo come possiamo rappresentare le entità<br/><br/>
		<table>
			<thead>
				<tr>
					<th>entità</th>
					<th>QAK</th>
					<th>motivazione/scelta</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><em>client</em></td>
					<td>attore</td>
					<td>entità autonoma che interagisce con altre entità e deve essere in grado di ricevere ed elaborare i messaggi</td>
				</tr>
				<tr>
					<td><em>waiter</em></td>
					<td>attore</td>
					<td>Per gli stessi motivi di <em>client</em></td>
				</tr>
				<tr>
					<td><em>barman</em></td>
					<td>attore</td>
					<td>Per gli stessi motivi di <em>client</em></td>
				</tr>
				<tr>
					<td><em>smartbell</em></td>
					<td>attore</td>
					<td>Per gli stessi motivi di <em>client</em></td>
				</tr>
				<tr>
					<td><em>table</em></td>
					<td>variabile</td>
					<td>Non scambia messaggi</td>
				</tr>
			</tbody>
		</table>
		<br/>
		Inoltre non parleremo più di messaggi ma di <b>Dispatch</b>, <b>Request</b>-<b>Reply</b> e <b>Event</b>.
		Ridefiniamo i messaggi individuati nello sprint iniziale traducendoli nella <b>semantica</b> del modello QAK:
		</br>
		</br>
		<table>
			<thead>
				<tr>
					<th>nome messaggio</th>
					<th>QAK</th>
					<th>motivazione/scelta</th>
					<th>parametri</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><em>clientRingEntryRequest</em></td>
					<td>Request</td>
					<td>Non usiamo un Event perchè non vogliamo che altri waiter possano ascoltare il messaggio e produrre molteplici risposte. Inoltre, dovendo il <em>client</em> ricevere una risposta, scegliamo di adottare una Request-Reply.</td>
					<td></td>
				</tr>
				<tr>
					<td><em>clientRingEntryReply</em></td>
					<td>Reply</td>
					<td>vedi sopra.</td>
					<td></td>
				</tr>
				<tr>
					<td><em>smartbellEntryRequest</em></td>
					<td>Request</td>
					<td>Come <em>clientRingEntryRequest</em></td>
					<td>ID cliente</td>
				</tr>
				<tr>
					<td><em>smartbellEntryReply</em></td>
					<td>Reply</td>
					<td>Come <em>smartbellEntryReply</em></td>
					<td>ID cliente</td>
				</tr>
				<tr>
					<td><em>clientOrderReady</em></td>
					<td>Dispatch</td>
					<td>Non usiamo un Event per lo stesso motivo di <em>clientEntryRequest</em>. Non si prevede una risposta quindi adottiamo un Dispatch. </td>
					<td>ID cliente</td>
				</tr>
				<tr>
					<td><em>clientOrder</em></td>
					<td>Dispatch</td>
					<td>Come <em>clientOrderReady</em></td>
					<td>ID cliente e drink ordinato</td>
				</tr>
				<tr>
					<td><em>waiterOrderForward</em></td>
					<td>Dispatch</td>
					<td>C'è sempre un solo <em>barman</em> quindi come <em>clientOrderReady</em></td>
					<td>ID cliente e drink ordinato</td>
				</tr>
				<tr>
					<td><em>barmanOrderReady</em></td>
					<td>Dispatch</td>
					<td>Come <em>clientOrderReady</em></td>
					<td>ID cliente</td>
				</tr>
				<tr>
					<td><em>clientPaymentReady</em></td>
					<td>Dispatch</td>
					<td>Come <em>clientOrderReady</em></td>
					<td>ID cliente</td>
				</tr>
			</tbody>
		</table>
		E ne aggiungiamo uno nuovo
		<table>
			<thead>
				<tr>
					<th>nome messaggio</th>
					<th>QAK</th>
					<th>motivazione/scelta</th>
					<th>parametri</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td><em>smartbellClientRejected</em></td>
					<td>Dispatch</td>
					<td>Messaggio che <em>smartbell</em> manda a se stesso per poter cambiare stato e attendere una nuova richiesta quando il <em>client</em> è rifiutato</td>
					<td>temperatura cliente</td>
				</tr>
			</tbody>
		</table>
		
		</br></br>
		Siamo già in grado di mostrare un primo <b>modello</b> al committente. Usiamo due contesti, uno per il <em>client</em>, uno per tutti gli altri attori.
		</br>
		</br>
		<a href="" onclick="openInNewTab('../../Sprint1/teaRoomAnReq1/src/tearoom.qak');">tearoom.qak</a>
		<br/>
		<br/>
		<a href="" onclick="openInNewTab('../../Sprint1/teaRoomAnReq1/src/client.qak');">client.qak</a>
		<br/>
		<br/>
		
	</div>
</body>
</html>