<html>
	<head>
		<link rel="stylesheet" type="text/css" href="../style/style.css">
		
		<script>
			function openInNewTab(url) {
				var win = window.open(url, '_blank');
				win.focus();
			}
		</script>
	</head>
	<body>
		<div class="body">
		Nello <a href="" onclick="openInNewTab('../../Sprint1/Sprint 1.html');">sprint 1</a> abbiamo deciso di mantenere lo stato complessivo della <em>tearoom</em> all'interno della waitermind tuttavia con i nuovi requisiti lo stato della
		<em>tearoom</em> è diventato più complesso e il <em>waiter</em> ha bisogno di prendere delle scelte a seconda dello stato.
		<br/>
		<br/>
		Allo scopo di allegerire da questi compiti la waitermind e di facilitare lo sviluppo futuro di una Web App che consenta il monitoraggio della <em>tearoom</em> secegliamo di introdurre un 
		nuovo attore <b>tearoomglobalstate</b> al quale gli altri attori si rivolgeranno per registrare cambiamenti nello stato della <em>tearoom</em>.
		<br/>
		<br/>
		Dall'analisi dei requisiti emerge la necessità di introdurre un <b>timer</b> in modo da tenere sotto controllo il tempo trascorso del task <em>clean</em>.
		Questo timer riceve un Dispatch con l'indicazione del tempo da cui partire.
		Dunque, quando si interrompe il task <em>clean</em>, viene memorizzato il tempo trascorso in modo da non dover ricominciare tutto da capo. 
		<br/>
		<br/>
		Possiamo riassumere il compito di ogni attore:
			<ul>
				<li>
					<b>waitermind:</b> master del waiterengine, mantine la logica di esecuzione;
				</li>
				<li>
					<b>waiterengine:</b> slave del waitermind, esegue i movimenti e le pulizie;
				</li>
				<li>
					<b>tearoomglobalstate:</b> mantiene lo stato complessivo della <em>tearoom</em> e risponde alla richieste di conoscenza di stato da parte di altri attori;
				</li>
				<li>
					<b>timer:</b> conta il tempo trascorso e all'interruzione informa il waiterengine che a sua volta aggiorna lo stato.
				</li>
			</ul>
			Il <b>tearoomglobalstate</b> può essere un potenziale collo di bottiglia ma dato che le azioni sono sufficientemente veloci il sistema non ne risente.
			<br/>
			<br/>
			Il <b>tearoomglobalstate</b> memorizza la <b>conoscenza di base</b> della <em>tearoom</em>, ovvero dove si trovano le entità, e i futuri cambiamenti di stato in un file <b>Prolog</b>.
			<br/>
			<br/>
			Inoltre, il <b>tearoomglobalstate</b> sceglie e ritorna quale <em>table</em> assegnare a un nuovo <em>client</em> controllando prima il <em>table</em> 1 e poi il <em>table</em> 2 perchè il <em>table</em> uno è quello più vicino alla porta.
			<br/>
			<br/>
			All'avvio del <em>waiter</em> si controlla subito che i <em>table</em> siano puliti perchè è possibile che siano sporchi dalla serata del giorno prima e in questo caso il <em>waiter</em> li pulisce
			<br/>
			<br/>
			Sono state individuate le seguenti <b>situazioni critiche</b>:
			<br/>
			<br/>
			<table>
				<thead>
					<tr>
						<th class="tg-0lax">Problematica</th>
						<th class="tg-0lax">Soluzione</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td class="tg-0lax">quale <em>table</em> pulisce per primo il <em>waiter</em> quando sono entrambi da pulire</td>
						<td class="tg-0lax">il <em>waiter</em> sceglie il <em>table</em> nella fase di pulizia più avanzata.</td>
					</tr>
					<tr>
						<td class="tg-0lax">gestione della richiesta di uscita a timer scaduto</td>
						<td class="tg-0lax">se arriva una richiesta di uscita dalla stanza quando è già scattata il maxstaytime viene ingnorata.</td>
					</tr>
					<tr>
						<td class="tg-0lax">gestione drink per <em>client</em> non al <em>table</em></td>
						<td class="tg-0lax">il <em>client</em> non è seduto all'interno della stanza perchè ha chiesto di pagare prima, quando il <em>barman</em> dice che l'ordine è pronto il <em>waiter</em> va al bar,
						ignora il drink e controlla la coda.</td>
					</tr>
					<tr>
						<td class="tg-0lax">gestione della <em>collect</em> quando il <em>client</em> viene cacciato prima di ordinare</td>
						<td class="tg-0lax">dato che non abbiamo messo informazioni sul pagamento il <em>waiter</em> esegue le stesse operazioni come se il <em>client</em> dovesse pagare.</td>
					</tr>
					<tr>
						<td class="tg-0lax">calcolo del tempo di attesa per l'<em>inform</em></td>
						<td class="tg-0lax">il <em>client</em> viene informato dallo <em>smartbell</em> del tempo esatto massimo (maxstaytime più corto + tempo di pulizia) di attesa, senza contare interruzioni nella pulizia, prima di trovare un <em>table</em> pulito.
						L'attesa non viene gestita tramite una coda ma il <em>client</em> deve risuonare il <em>smartbell</em>.</td>
					</tr>
				</tbody>
			</table>
			<br/>
			Inoltre, il modello è stato <b>raffinato</b> ulteriormente:
			nello sprint 1 solo quando il <em>waiter</em> ritorna in <em>home</em> vede se ci sono altre azioni
			da eseguire mentre adesso viene interrotto mentre va verso <em>home</em>. 
			<br/>
			<br/>
			Sono stati aggiunti altri tre <b>attori</b> per soddisfare il requisito di <em>maxstaytime</em>.
			Per <em>maxstaytime</em> si intende il tempo che il <em>client</em> ha a disposizione per effettuare la sua consumazione nella <em>tearoom</em>.
			Quando il <em>client</em> decide cosa prendere, il contatore parte e viene bloccato quando viene fatta la Request dal <em>client</em> al <em>waiter</em> quando il <em>client</em> deve ordinare.
			Per semplificare l'accesso a <em>maxstaytime</em> di ogni <em>client</em> è stato introdotto un attore chiamato <b>maxstaytimer</b>.
			Esso gestisce il tempo a disposizione ad ogni <em>client</em> inviando al waitermind un Dispatch quando il tempo scade.
			L'attore maxstaytimer usa due attori, ciascuno dei quali gestisce a sua volta il tempo trascorso per ogni <em>client</em> nella <em>tearoom</em>.
			<br/>
			<br/>
			Dunque, da un punto di <b>vista logico</b> il nostro sistema è formato da più attori in contesti diversi:
			<br/>
			<br/>
			<img src="../img/interazioni2a.png" alt="img" width="75%" height="85%">
			<img src="../img/interazioni2b.png" alt="img" width="75%" height="85%">
			<br/>
			<br/>
			Di seguito è riportato il <b>modello</b>.
			<br/>
			<br/>
			<a href="" onclick="openInNewTab('../../Sprint2/teaRoomAnProbl2/src/tearoom.qak');">tearoom.qak</a>
			<br/>
			<br/>
			<a href="" onClick="openInNewTab('../../Sprint2/teaRoomAnProbl2/src/client.qak');">client.qak</a>
			<br/>
			<br/>
		</div>
	</body>
</html>