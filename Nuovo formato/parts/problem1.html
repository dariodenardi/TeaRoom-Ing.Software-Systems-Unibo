<html>
	<head>
		<link rel="stylesheet" type="text/css" href="../style/style.css">
	</head>
	<body>
		<div class="body">
			Dall'analisi emersa dallo <a href="./sprint0.html">sprint precedente</a>, si nota che la maggior parte dei task per funzionare hanno bisogno del movimento.
			Per questo motivo viene introdotta un'entità esterna detta <em>planner</em>.
			Il suo compito è quello di far raggiungere al <em>waiter</em> la posizione desiderata nella <em>tearoom</em>. Per far ciò è necessario che il <em>planner</em> 
			conosca la mappa della stanza a priori.
			</br>
			La mappa viene creata dal <em>planner</em> utilizzando <em>boundarywalker</em> e <em>mappingwalker</em> che esplorano l'ambiente creano un file txt. Essa deve essere interpretata nel seguente modo:

			<ul>
			<li><b>r:</b> cella occupata dal robot;</li>
			<li><b>1:</b> cella esplorata dal robot;</li>
			<li><b>0:</b> cella non ancora esplorata;</li>
			<li><b>X:</b> cella che contiene un ostacolo.</li>
			</ul>

			Inoltre, la mappa <b>non</b> presenta ostacoli mobili ma solo fissi per cui non serve che sia riconfigurata ogni volta nel <em>planner</em>.
			Il <em>planner</em> vede la <em>tearoom</em> come un insieme di celle della dimensione del robot ognuna delle quali è caratterizzata da un punto bidimensionale XY.
			<br/>
			Chiamiamo con il termine <b>step</b> l'unità dello spostamento del <em>waiter</em> da una cella ad un'altra adiacente corrispondente alla lunghezza del robot.
			<br/>
			Tuttavia, i veri spostamenti vengono effettuati dal <a href="https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.qak20.robotboundary/userDocs/Qak20Robotboundary.html">basicrobot</a>: il <b>mind</b> chiede uno spostamento all'<b>engine</b> che a sua volta inoltra la richiesta al basicrobot.
			</br>
			</br>
			Consideriamo il <em>barman</em> come attore esterno che riceverà 
			un messaggio (ordine del cliente)
			e risponderà, dopo un tempo (random) di preparazione, con un messaggio per indicare
			che il drink è pronto.
			Allo stesso modo il cliente verrà simulato come entità esterna al fine di testare
			e garantire il corretto funzionamento.
			Per il primo sprint queste due entità sono state simulate in un solo main di test.
			</br>
			</br>
			Facendo riferimento allo <a href="./sprint0.html">sprint iniziale</a>, sarebbe opportuno modellare lo stato del tavolo all'interno dell'entità che tiene lo stato della <em>tearoom</em>.
			Per una prima e veloce modellazione tralasciamo questa entità e inseriamo gli stati dei tavoli all'interno del <b>mind</b>.
			</br>
			</br>
			Proseguiamo quindi con la modellazione dei due attori che compongono il <em>waiter</em> tramite grafi degli stati.
			<br/>
			<br/>
			<em>Engine:</em>
			<!--Grafo ENGINE-->
			<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2020-07-01T14:21:33.755Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\&quot; etag=\&quot;DWnHhTsUBkdLeFMWrY2c\&quot; version=\&quot;13.3.5\&quot;&gt;&lt;diagram id=\&quot;2zA2yLJ3x4JN4bZLVGS_\&quot; name=\&quot;Page-1\&quot;&gt;7Vtbc5s4FP41ntl9cAZxs/NY23E67XqbWWe2zdOOYgRmKxAF+dZfXwGyuQhj7BijnU0eEnSQhHT0ne8cHSk9bextH0MYLGfEQrinKta2p016qnqvq+x3LNilAjBQuMQJXYvLMsHc/Ym4UOHSlWuhqFCREoKpGxSFC+L7aEELMhiGZFOsZhNc/GoAHSQI5guIRelX16LLVDpUB5n8I3Kd5f7LwLxP33hwX5nPJFpCi2xyIu2hp41DQmj65G3HCMfK2+slbTc98vYwsBD5tEkD+2s0c7y/LHP7N3wBn5/61vdhnw92DfGKT7inmpj1N4oC6MejpjuuCvPHKh7qaEEwCXvaB/YydF5/GzBNsA+P2e8hyB7N3+NnbZTo3Kd9G3ou3qXNWF/QC5KXmqazvzB0IRakh84i6Ef9CIWuXewzStAS9wj0YHt4R9GW9iF2HT99iZFNs+GzJyf5O37ojYz9bJna0gmnL/seX7PD7FVkMVzwIgnpkjjEh/ghk45CsvItFGs7HkhW5w9C2LQmgAn/RZTuOMjhihImWlIP87do69JvueeXuKs7g5cmW95zUtjtCz4Nd9/yhVyruJg1S0pZO+tDbB7xbALkp5KpizF/L6KLAy4iq3CBaiC1t1IYOojW1OM8EOs19wGO3UdEPMTGG4MMYUjdddEeITdr51AvQz574OA/wxCAYAiRImAgW+F4iTZLl6J5ABNtbBj9FVfTZsocp7bC2mpj9jOd1ml2jUIG3Vpd8LcDPjROqiYvbjKCAnvWWebIaV/v6sobCMpbYBRbkyw2pF5mRGp3VqQ2tCJTLitSBCR4ZI2eSZdQUO4GRg4N4CIoyI8EoyESOIcodzowueE2Bgfv7Ym4bBZZFWLbERtbGT2HjzYC1PfF9Mvr4vP9i/XpZTp5Xv7Ef/6zn3wOT0yt3YIpjyWlIZYy+BwQWIOles9RWuCrgapS/52yibj4G+jSsScCQBbHrA6788yP9uTJmgZPkT6bOZ/mP76MvKgPRB1GFAUW8VGnVlTwzoOG3hn0CpQ8OMXJl5uHJppHtXqv7X2TpsyRwF2uQhDTbVTBvxx1ulpEnTY08sA5Wd8ARglo6QguZfJqVWmVSLShi5FEjF4fHVwVUdURlFwBnbhoaIsWc7Zw0nKwAUrWoHe9Paog4Z4xoiErGJMuoQ8uomF5Nkl6Q6PSpLIpoFfBwYY46hoPRbd8Cg71q3rMa7fntCvQUOmJrp54OuJl9SIPqfclfkkHylu9aetUp44cykIELampWysFJqrROXWLecH3BHmv6wT5OSHbsU24coKH2vNaRkOvpUuxuTDMkk1qSsmq3rZZqFNRzuoCDP2n+EhNVu4ylKKeQOfcNTxKXZa7rmSuhsRwQwLkPRb57zCeM+nvLIaTepbHliT+ROVgy/oAVfqISf2gi7SrYvdHVPQaVlRMMLaXyhLStpVpOuUsMHxFeAQX351kYjkKspOfOgpqPU69vy8Sl2IUu0gdmhCnCh1ppzpqOeA1Bb5LTiGf4SsWk52yuo3Oz3KB6HvfI97uI942dub53E2Tc6nLQ17QNP15o725VtqbA63Z3vzc4Ll8UcMoXdGqrw6G9dU1UFu/ndC8Io/P4CV1aF5OK5jqDUm2MgVVce1OwoTwZcHSyXzwG2jEbEgjTbfOHCB9NmqNt2l3Nz0wilDcu/+jjFCqzyjkuIm3dDGj+jhPvOkjSxL7suTQ4Kzs0A0wDDo7tahccPGO3397vdXrr3fdFYHrLXfGWYqpGpeQ1i15oiIJJaGna3w/tI2I+U2wOdPTKXe6OjRlB4146LIKLEjRDMp7dgVKQaY+6DrIVAUtxnc3ZmQtbzakrMSb3t2oVGLFWf17Ev09if4/S6JLcN76lhT6SW+rit72hvc9xTNXpZRJBxem5PVTHbWckgdiTh6xRQ4/Qt/CKJTWD5XvEN7UmR+/iF/Ous0pC4raVKKgsQq9HlVi+TJ8v8UTcVbM/pM2RW/2/8jawy8=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
			<script type="text/javascript" src="https://app.diagrams.net/js/viewer.min.js"></script>
			</br>
			Componente che pulisce il tavolo e gestisce il movimento del <em>waiter</em>. L'idea è che <em>Engine</em> ottenga da <em>planner</em> una successione di step da eseguire al fine di attuare il movimento richiesto e che si interfacci con basicrobot per l'esecuzione di ogni step. 
			<em>Engine</em> viene attivato da <em>Mind</em> e come ultima istruzione del suo stato iniziale &lt;s0&gt; invia a <em>Mind</em> una dispatch <u>engineReady</u>.
			A partire dallo stato &lt;waitCmd&gt; si possono seguire tre sequenze di transizioni, innescate da 3 messaggi diversi:
			<ul>
				<li>
					<u>end</u>, provoca la terminazione di <em>Engine</em> 
				</li>
				<li>
					<u>clean</u>, contiene un parametro che specifica il tipo di pulizia da eseguire. Per rendere un tavolo di nuovo usufruibile da un cliente, <em>Engine</em> dovrà ricevere 3 messaggi <u>clean</u>, ogni volta con parametro diverso, in questo ordine: clear, sanitize e clean.
				</li>
				<li>
					<u>moveTo</u>: contiene un parametro che esprime la posizione (x,y) che si vuole raggiungere nella <em>tearoom</em>. In &lt;planPath&gt; si ottiene la lista di step da eseguire da <em>planner</em> e poi vengono eseguiti uno ad uno. Nello stato &lt;readStep&gt; si controlla se lo step può ritornare errore e si transita di conseguenza in uno stato che esegue lo step (&lt;execStep&gt; o &lt;execMove&gt;). Poi si passa in uno stato dove si aggiorna lo stato della <em>tearoom</em> indicando la nuova posizione del <em>waiter</em> e si controlla se sono rimasti step da fare. Se sì <em>Engine</em> torna a &lt;readStep&gt; altrimenti passa a &lt;endPath&gt;
				</li>
			</ul>

			<em>Mind:</em>
			<!--Grafo MIND-->
			<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2020-07-01T13:48:17.380Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\&quot; etag=\&quot;LrUQCHodJarrZo370RNr\&quot; version=\&quot;13.3.5\&quot;&gt;&lt;diagram id=\&quot;cU18ib_VpRdZYBQb-qZ6\&quot; name=\&quot;Page-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
			<script type="text/javascript" src="https://app.diagrams.net/js/viewer.min.js"></script>
			</br>
			Componente di <em>waiter</em> che mantiene il controllo sul task in esecuzione. Nello sviluppo del grafo degli stati si è mantenuto l'approccio per sequenze di transizioni per cui ogni sequenza rappresenta un compito dell'attore. Nel caso di <em>Mind</em> una sequenza rappresenta un task (o gruppi di task). Lo stato &lt;rest&gt; è molto simile al &lt;waitCmd&gt; di <em>Engine</em>, in quanto è punto di partenza delle sequenze di transizioni. Le transizioni terminano in &lt;reachHome&gt;</br>
			Tutti gli stati di <em>Mind</em> che hanno nome con prefisso "reach", "convoy" o "serve" implicano uno spostamento del <em>waiter</em> e quindi l'invio a <em>Engine</em> di una request <u>moveTo</u>. Per questo motivo la transizione di uscita da questi stati è innescata da una reply <u>done</u> proveniente da <em>Engine</em>, che indica il completamento dello spostamento.</br>
			Gli stati "reach" rappresentano un movimento in cui il <em>waiter</em> è da solo. Negli stati "convoy" il <em>waiter</em> accompagna il cliente a destinazione, mentre nello stato "serve" il <em>waiter</em> porta con sé un drink. Si noti anche che ogni stato di movimento specifica il motivo per cui ci si deve spostare verso la destinazione: ad esempio &lt;reachTableCollect&gt;, &lt;reachTableClean&gt;, &lt;convoyTable&gt;, &lt;reachTableOrder&gt; e &lt;serveTable&gt; rappresentano tutti movimenti verso il tavolo ma il compito del <em>waiter</em> cambia da stato a stato. </br>
			Ci sono 3 dispatch e 1 request che provocano altrettante sequenze distinte di transizioni:
			<ul>
				<li>
					<u>clientEntryRequest</u> : request inviata dal cliente, indica che il cliente vuole entrare nella <em>tearoom</em>.
					Stando alle <a href="#ass">assunzioni</a> il controllo sulla condizione dei tavoli ritorna sempre che c'è un tavolo libero, quindi clientEntryRequest provoca la transizione allo stato &lt;accept&gt;.
					La sequenza di transizioni termina quando il cliente è stato portato al tavolo.
				</li>
				<li>
					<u>clientOrderReady</u>: dispatch inviata dal cliente, indica che il cliente è pronto per ordinare. La sequenza di transizioni termina con la trasmissione dell'ordine a <em>barman</em>. Dato che <em>waiter</em> usa sempre lo stesso tavolo, secondo le <a href="#ass">assunzioni</a> di questo sprint la dispatch non contiene parametri. In futuro potrebbe essere opportuno inserire l'id del cliente o il numero di tavolo.
				</li>
				<li>
					<u>barmanOrderReady</u>: dispatch inviata da <em>barman</em>, indica che il drink è pronto. Come per il caso precedente non contiene parametri ma in futuro potrà essere opportuno aggiungerne. La sequenza di transizioni termina quando il <em>waiter</em> ha portato il drink al tavolo. 
				</li>
				<li>
					<u>clientPaymentReady</u>: dispatch inviata da cliente, indica che il cliente vuole pagare e uscire. Subito dopo averlo accompagnato alla porta di uscita <em>waiter</em> comincia a pulire il tavolo usato. La sequenza di transizioni termina quando il tavolo è di nuovo pulito.
				</li>
			</ul>
			Siamo già in grado di mostrare un primo <b>prototipo</b> al committente grazie all'ausilio di un <a href="https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.virtualRobot2020/userDocs/LabVirtualRobot.html">robot virtuale</a>.
			<pre>
			System tearoom

			//messages
			Request clientEntryRequest : clientEntryRequest(ID)
			Reply acceptClientReply : acceptClientReply(ID)

			Dispatch clientEntryRequest : clientEntryRequest(P)
			Dispatch clientOrderReady : clientOrderReady(P)
			Dispatch waiterOrderForward : waiterOrderForward(T)
			Dispatch barmanOrderReady : barmanOrderReady(T)
			Dispatch clientPaymentReady : clientPaymentReady(P)

			Dispatch clean : clean(R)
			Dispatch doneCleanRun : doneCleanRun(P)

			Dispatch engineReady : engineReady(P)
			Request moveTo : moveTo(X,Y)
			Reply done : done(X,Y)

			Dispatch end : end(V)

			Request step : step( TIME )	
			Reply   stepdone   : stepdone(V)  
			Dispatch cmd : cmd(MOVE)
			Reply   stepfail   : stepfail(DURATION, CAUSE)
			//end messages

			//context and QActors 
			/*USE JSON FILE TO READ HOST AND PORT */
			Context ctxtearoom ip [host="127.0.0.1" port=8040]
			Context ctxbasicrobot ip [host="localhost" port=8020] 
			ExternalQActor basicrobot context ctxbasicrobot 
			//ExternalQActor waiterengine context ctxTearoom
			//end context and Qactors

			QActor waitermind context ctxtearoom{
				//inizializzazione varibili
				[#		
					val DoClear = 1
					val DoSanitize = 2
					val DoClean = 3
					
					val CollectTime = 4000L
							 
					val X_home = "0"
					val Y_home = "0"
					
					val X_bar = "6"
					val Y_bar = "0"
					
					val X_entrance = "0"
					val Y_entrance = "4"
					
					val X_exit = "6"
					val Y_exit = "4"
					
					val X_table_1 = "2"
					val Y_table_1 = "2"
					
					val X_table_2 = "0"
					val Y_table_2 = "0"
					
					data class Table(var state: String ="tableClean") { }
					val table1 = Table()
					val table2 = Table()
					var stateTable1 = "tableClean"
					var stateTable2 = "tableClean"
				#]
				
				State startState initial{
					println("waitermind || START")
					updateResource [# "startState" #]
				}
				Transition t0	whenMsg engineReady -> rest
				
				State rest{
					println("waitermind || rest")
					updateResource [# "rest "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
				}//end rest
				Transition t1	whenRequest clientEntryRequest -> accept
								whenMsg clientOrderReady -> reachTableOrder
								whenMsg barmanOrderReady -> reachBar
								whenMsg end -> endState
								whenMsg clientPaymentReady -> reachTableCollect
								
				State reachHome{
					println("waitermind || reachHome")
					updateResource [# "reachHome" #]
					delay 1000
					request waiterengine -m moveTo : moveTo($X_home, $Y_home)
					
				}//end reachHome
				Transition t2	whenReply done -> rest
				
				State accept{
					println("waitermind || accept")
					updateResource [# "accept" #]
					onMsg(clientEntryRequest : clientEntryRequest(ID)){
						replyTo clientEntryRequest with acceptClientReply : acceptClientReply(payloadArg(0))	
					}
							
				}//end accept
				Goto	reachDoor
				
				State reachDoor{
					println("waitermind || reachDoor")
					updateResource [# "reachDoor" #]
					request waiterengine -m moveTo : moveTo($X_entrance, $Y_entrance)
					
				}//end reachDoor
				Transition t3	whenReply done -> convoyTable
				
				State convoyTable{
					println("waitermind || convoyTable")
					updateResource [# "convoyTable "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					//updateResource [# "convoyTable"#]
					//attendo e prendo il cliente
					delay 500
					//STATO TAVOLO TO CHANGE
					//Controllare il tavolo libero
					request waiterengine -m moveTo : moveTo($X_table_1, $Y_table_1)
				}//end convoyTable
				Transition t4	whenReply done -> reachHome
				
				
				State reachTableOrder{
					println("waitermind || reachTableOrder")
					updateResource [# "reachTableOrder "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					//check table ordering
					request waiterengine -m moveTo : moveTo($X_table_1, $Y_table_1)
					
				}//end reachTableOrder
				Transition t5	whenReply done -> trasmit

				
				State trasmit {
					println("waitermind || trasmit")
					updateResource [# "trasmit "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]	
					delay 1000
					//forward barman -m order : order(payloadArg(0))
					//segna tavolo cos' il bar lo sa
				}// end trasmit
				Goto reachHome
				
				State reachBar{
					println("waitermind || reachBar")
					updateResource [# "reachBar "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]	
					request waiterengine -m moveTo : moveTo($X_bar, $Y_bar)
				}//end reachBar
				Transition t6	whenReply done -> serveTable
				
				State serveTable{
					println("waitermind || serveTable")
					updateResource [# "serveTable "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]	
					delay 1000
					//onMsg(barmanOrderReady : barmanOrderReady(T)){
					//tavolo contenuto nel messaggio del barman
					request waiterengine -m moveTo : moveTo($X_table_1, $Y_table_1)
					//}
					//request waiterengine -m moveTo : moveTo($X_bar, $Y_bar)
					
					//STATO DEL TAVOLO DA CAMBIARE
					[# table1.state = "tableDirty" #]
				}//end serveTable
				Transition t7	whenReply done -> reachHome
				
				State reachTableCollect{
					println("waitermind || reachTableCollect")
					updateResource [# "reachTableCollect "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					//guardo il messaggio clientPaymentReady e leggo ID e capisco tavolo
					request waiterengine -m moveTo : moveTo($X_table_1, $Y_table_1)	
				}//end reachTableCollect
				Transition t8	whenReply done -> collect
					
				
				
				State collect{
					println("waitermind || collect")
					updateResource [# "collect "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					//delay time perchè ci metto un po' a prendere il cash
					delayVar CollectTime
				}//end collect
				Goto convoyExit
				
				State convoyExit{
					println("waitermind || convoyExit")
					updateResource [# "convoyExit "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					
					request waiterengine -m moveTo : moveTo($X_exit, $Y_exit)	
					
				}//end convoyExit
				Transition t9 	whenReply done -> reachTableClean
				
				State reachTableClean{
					println("waitermind || reachTableClean")
					updateResource [# "reachTableClean "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					delay 1000
					//mi muovo verso il tavolo
					request waiterengine -m moveTo : moveTo($X_table_1, $Y_table_1)		
				}//end reachTableClear
				Transition t10 	whenReply done -> tableClearing
				

				State tableClearing{
					println("waitermind || tableClearing")
					updateResource [# "tableClearing "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					
					[# table1.state = "tableClearing" #]
					
					forward waiterengine -m clean : clean($DoClear)

					//DICO ALL'ENGINE DI PULIRE
					//delayVar TableClearTime
					//STATO DEL TAVOLO DA CAMBIARE
					//[# table1.state = "tableCleared" #]

				}//end tableClear
				Transition t11	whenMsg doneCleanRun -> tableSanitizing
				
				
				State tableSanitizing{
					println("waitermind || tableSanitizing")
					updateResource [# "tableSanitizing "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					
					[# table1.state = "tableSanitizing" #]
					
					forward waiterengine -m clean : clean($DoSanitize)
				}//end tableSanitize
				Transition t12	whenMsg doneCleanRun -> tableCleaning
				
				
				State tableCleaning{
					println("waitermind || tableCleaning")
					updateResource [# "tableCleaning "+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY() #]
					
					[# table1.state = "tableCleaning" #]
					
					forward waiterengine -m clean : clean($DoClean)
				}//end tableClean
				Transition t12	whenMsg doneCleanRun -> updateTableCleaned
				
				State updateTableCleaned{
					println("waitermind || updateTableCleaned")
					updateResource [# "updateTableCleaned" #]
					
					[# table1.state = "tableCleaned" #]
				}
				Goto	reachHome
				
				
				
				State endState{
					println("waitermind || TERMINATES")
					terminate 0
				}//end endState
				
				
				
			}

			QActor waiterengine context ctxtearoom{ 
				
					[# 
						var StepTime = 445L
						val BackTime     = 2 * StepTime / 3
						
						val mapRoom  = "teaRoomExplored"
						var XPoint = "0"
						var YPoint = "0"
						
						val TableClearTime = 4000L
						val TableSanitizeTime = 2000L
						val TableCleanTime = 2000L
						
						var CmdToPerform = ""  
					#]
					
				State s0 initial{
					println("waiterengine || START")
					updateResource [# "startState" #]
					
				
					run itunibo.planner.plannerUtil.initAI() 
					run itunibo.planner.plannerUtil.loadRoomMap(mapRoom) 		
					run itunibo.planner.plannerUtil.showCurrentRobotState()	
					
					forward waitermind -m engineReady : engineReady(P)
				}
				Goto waitCmd
				
				
				State waitCmd{
					println("waiterengine || waitCmd")
					updateResource [# "waitCmd" #]
				}
				Transition t0	whenRequest moveTo -> planPath
								whenMsg clean -> cleanTable
				
				
				
				State planPath{
					println("waiterengine || planPath")
					updateResource [# "planPath" #]
					onMsg(moveTo : moveTo(X,Y)){
						[# XPoint = payloadArg(0)
						   YPoint = payloadArg(1)			  
						 #]
						 }
						println("moveTo ($XPoint,$YPoint)")
						run itunibo.planner.plannerUtil.planForGoal("$XPoint","$YPoint")
				}
				Goto readStep
				
				State readStep{
			//		println("waiterengine || readStep")
						[#  CmdToPerform = itunibo.planner.plannerUtil.getNextPlannedMove() #]
				}
				Goto execStep if  [# CmdToPerform == "w"#] else execMove
				//funziona? se mi trovo già al punto che succede?
				
				State execMove{
			//		println("waiterengine || execMove")
					forward basicrobot -m cmd : cmd($CmdToPerform)
					delay 200
				}
				Goto updateMap
				
				
				State endPath{
					println("waiterengine || endPath")
					updateResource [# "endPath" #]
					println("done moveTo($XPoint,$YPoint)")
					run itunibo.planner.plannerUtil.showCurrentRobotState()
					replyTo moveTo with done : done($XPoint,$YPoint)
				}
				Goto waitCmd
				
				State execStep{
			//		println("waiterengine || execStep")
					request basicrobot -m step : step($StepTime)
				}
				Transition t1	whenReply stepdone -> updateMap
								whenReply stepfail   -> errorHandler
				
				State updateMap{
					updateResource [# itunibo.planner.plannerUtil.getMapOneLine() #]
					run itunibo.planner.plannerUtil.updateMap("$CmdToPerform")	
					
				}
				Goto readStep if [# CmdToPerform.length > 0 #] else endPath
				
				State errorHandler{
					println("waiterengine | errorHandler")
					//torno indietro di un po'
					
					onMsg(stepfail : stepfail(DURATION, CAUSE) ){
						[# val D = payloadArg(0).toLong()  ; val Dt = Math.abs(StepTime-D); val BackT = D/2 #] 
						println("robotmapper stepFail D= $D, BackTime = ${BackTime} BackT=$BackT")
			 			if [# D > BackTime #] {    
							forward basicrobot -m cmd : cmd( s )
							delayVar BackT
							forward basicrobot -m cmd : cmd( h )
						}	
			//	 		if [# ! itunibo.planner.plannerUtil.atHome() #]{
				 			run itunibo.planner.plannerUtil.updateMapObstacleOnCurrentDirection()
			//	 		}
				 		run itunibo.planner.plannerUtil.showCurrentRobotState()
						updateResource [# "stepFail" #]
						delay 500	
					}	    
				}
				Goto readStep if [# CmdToPerform.length > 0 #] else endPath
				

				State cleanTable{
					onMsg(clean : clean(R)){
						if [# payloadArg(0) == "1" #] 
						{//sono in clear
							delayVar TableClearTime
						}//else if
						if [# payloadArg(0) == "2" #]
						{
							delayVar TableSanitizeTime
						}
						if [# payloadArg(0) == "3" #]
						{
							delayVar TableCleanTime
						}
					}
					forward waitermind -m doneCleanRun : doneCleanRun(P)
				}
				Goto waitCmd
				
				
			}
			</pre>
		</div>
	</body>
</html>