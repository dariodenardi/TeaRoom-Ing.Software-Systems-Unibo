System tearoom 

//Messages **********************************************************************
//DIVISI PER CHI INVIA 
 
//**********CLIENT 
 
Request clientRingEntryRequest : clientEntryRequest(PAYLOAD)
Reply clientRingEntryReply : clientRingEntryReply(ENTRATA, ID) //invia smartbell in realtà

Dispatch clientOrderReady : clientOrderReady(ID)
Dispatch clientOrder : clientOrder (ID, ORDER)
Dispatch clientPaymentReady : clientPaymentReady(ID)

//**********SMARTBELL
Request smartbellEntryRequest : smartbellEntryRequest(ID)
Reply smartbellEntryReply : smartbellEntryReply(ENTRATA, ID)
Dispatch smartbellClientRejected : smartbellClientRejected(TEMP) //verso se stesso


//**********BARMAN
Dispatch barmanOrderReady : barmanOrderReady(ID) //= a tavolo o cliente id (per distinguere in futuro)


//**********WAITER
Dispatch waiterOrderForward : waiterOrderForward(ID, ORDER) //Order contenente ID cl. o tavolo (in futuro per distringuere)

//**********WAITER interni
Dispatch clean : clean(R, TIMER)
Dispatch doneCleanRun : doneCleanRun(P)
Dispatch engineReady : engineReady(P) 

Dispatch moveTo : moveTo(X,Y)
Dispatch done : done(X,Y)

Dispatch end : end(V)
Request step : step( TIME )	
Reply   stepdone   : stepdone(V)  
Dispatch cmd : cmd(MOVE) 
Reply   stepfail   : stepfail(DURATION, CAUSE) 

//***************************Messaggi 2' SPRINT
Dispatch startTimerCleaning : startTimerCleaning(TIMER) //da engine a timercleaning

Request stopTimerCleaningReq : stopTimerCleaningReq(P) //da engine a timercleaning
Reply stopTimerCleaningReply : stopTimerCleaningReply(TIMERDONE)//da timercleaning a engine

Dispatch timerFinishedCorrectly : timerFinishedCorrectly(P) //da timercleaning a engine

Dispatch stopCleaningEngine : stopCleaningEngine(TAVOLO) //da Mind a engine
//Reply  stopCleaningReply : stopCleaningReply(TIMERDONE) //da engine a Mind

Dispatch goToClearing : goToClearing(P)
Dispatch goToSanitizing : goToSanitizing (P)
Dispatch goToCleaning : goToCleaning(P)

//***************************Messaggi 3' SPRINT

Dispatch stopEngineMove : stopEngineMove(P)
Dispatch setWaiterState : setWaiterState(STATO)

Dispatch removeOrderReady : removeOrderReady(ID)
Dispatch addOrderReady : addOrderReady(ID)
Dispatch setBarmanState : setBarmanState(STATO)

Dispatch addClientAccepted : addClientAccepted(P)
Dispatch addClientRejected : addClientRejected(P)

Dispatch setStateTable : setStateTable(N, STATO, TIMERDONE)

Dispatch occupyTable : occupyTable(N, ID)

Request getTableToCleanReq : getTableToCleanReq(P)
Reply 	getTableToCleanReply : getTableToCleanReply(N, STATO, TIMERDONE)

Request getFreeCleanTableReq : getFreeCleanTableReq(P)
Reply 	getFreeCleanTableReply : getFreeCleanTableReply(N)


Request getTable1StateReq : getTable1StateReq(N)
Request getTable2StateReq : getTable2StateReq(N)
Reply	getTableNStateReply : getTableNStateRep(N, STATO, TIMERDONE)

Request getTableFromIdReq : getTableFromIdReq(ID)
Reply 	getTableFromIdReply : getTableFromIdReply(N)

Dispatch setTimerTableStopped : setTimerTableStopped(N, TIMER)

Dispatch startTimer : startTimer(N)
Dispatch stopTimer : stopTimer(N)
Dispatch resumeTimer : resumeTimer(N)
Dispatch maxStayTimerExpired : maxStayTimerExpired(N)

Request	 getMaxStayTimeLeftReq : getMaxStayTimeLeftReq(P)
Reply	 getMaxStayTimeLeftReply : getMaxStayTimeLeftReply(TIMERLEFT)

Request	 askMaxStayTimeLeftReq : askMaxStayTimeLeftReq(N)
Reply	 askMaxStayTimeLeftReply : askMaxStayTimeLeftReply(TIMERLEFT)

Request	 getTimerForInformReq : getTimerForInformReq(P)
Reply	 getTimerForInformReply : getTimerForInformReply(TIMER)



//end messages ******************************************************************* 
//context and QActors 
 
Context ctxtearoom ip [host="127.0.0.1" port=8040] 
Context ctxbasicrobot ip [host="localhost" port=8020] 
ExternalQActor basicrobot context ctxbasicrobot 
//ExternalQActor waiterengine context ctxTearoom
//end context and Qactors 


QActor waitermind context ctxtearoom{
	//inizializzazione varibili
	[#		
		val DoClear = 1
		val DoSanitize = 2
		val DoClean = 3
		
		val ClearTime = 6000L
		val SanitizeTime = 5000L
		val CleanTime = 5000L
		
		val CollectTime = 4000L
		val DelayTakeDrink = 2000L
		val DelayServeDrink = 2000L
		val DelayTakeClient = 2000L
				 

		var CleaningON = false
		
		var TableToClean = 0
		var TableStateToClean = ""
		var TableTimerDone = 0L
		
		var TableToOccupy = 0
		var IdClientOccupy = 0
		
		var TableForOrder = ""
		var IdForOrder = 0
		
		var TableForCollect = ""
		
		var TimerTable1 = 0 
		var TimerTable2 = 0
		
		var MoveX = 0
		var MoveY = 0

	#]
	
	State startState initial{
		println("waitermind 		|| START")
		updateResource [# "startState" #] 
		solve( consult("tearoomstate.pl") )
	}
	Transition t0	whenMsg engineReady -> checkTableToClean
	
	State checkQueue{
		println("waitermind		|| checkingQueue")
	}
	Transition t12	whenTime 100			 ->     checkTableToClean
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform
					
					
	State checkTableToClean{
		println("waitermind		|| checkTableToClean")
		request tearoomglobalstate -m getTableToCleanReq : getTableToCleanReq(P)		
	}
	Transition t1 whenReply getTableToCleanReply -> analizeReplyTableToClean
	
	
	State analizeReplyTableToClean{
		println("waitermind		|| analizeReplyTableToClean")
		onMsg (getTableToCleanReply : getTableToCleanReply(N, STATO, TIMERDONE)){
			[# 
				TableToClean =  payloadArg(0).toInt()
				TableStateToClean = payloadArg(1)
				TableTimerDone = payloadArg(2).toLong()
			
			#]	
		}
	}
	Goto reachHome if [# TableToClean == 0 #] else reachTableClean
	 
	
	State rest{
		println("waitermind 		|| rest")
		updateResource [# "rest"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(rest)
	}//end rest
	Transition t1	whenRequest smartbellEntryRequest -> acceptorinform
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg barmanOrderReady -> reachBar
					whenMsg end -> endState
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg maxStayTimerExpired -> reachTableKick
					
	State reachHome{
		//[# readLine() #]
		println("waitermind 		|| reachHome")
		updateResource [# "reachHome" #]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(reachHome)
		
		solve(pos(home, X, Y))
			ifSolved{
				[# 
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             }
		
	}//end reachHome
	Transition t2	whenMsg done -> rest
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform
					
	
	State acceptorinform{
		forward waiterengine -m stopEngineMove : stopEngineMove(P)
		if [#CleaningON == true #]{
			forward waiterengine -m stopCleaningEngine : stopCleaningEngine ($TableToClean)
			[# 
				CleaningON = false 
				TableToClean = 0
			#]
		}
		
		println("waitermind 		|| accept or inform")
		
		request tearoomglobalstate -m getFreeCleanTableReq : getFreeCleanTableReq(P)
		
		onMsg(smartbellEntryRequest : smartbellEntryRequest(ID)){
			println("waitermind 		|| Ricevuta richiesta da ID: ${ payloadArg(0) }")
			[#IdClientOccupy = payloadArg(0).toInt()#]	
		}
	}
	Transition	t1 		whenReply getFreeCleanTableReply -> analizeacceptorinform
	
	State analizeacceptorinform{
		onMsg (getFreeCleanTableReply : getFreeCleanTableReply(N)){
			[#
				TableToOccupy = payloadArg(0).toInt() 	
			#]
		}
	}
	Goto inform if [#TableToOccupy == 0#] else accept
	
	State inform{
		//non dovendo far sedere il cliente = 0 
		[#IdClientOccupy = 0#]
		
		
		//request maxstaytime -m getMaxStayTimeLeftReq : getMaxStayTimeLeftReq(1)		
		request tearoomglobalstate -m getTimerForInformReq : getTimerForInformReq(P)
	}
	Transition t0	whenReply  getTimerForInformReply -> analizeTimeForInform
	
	State analizeTimeForInform{
		onMsg (getTimerForInformReply : getTimerForInformReply(TIMER)){
			replyTo smartbellEntryRequest with smartbellEntryReply : smartbellEntryReply(inform, $payloadArg(0))
			//test inform
			updateResource[#"inform ${payloadArg(0)}"#]	
		}
		//test inform
		//[# readLine() #]
	}
	Goto checkQueue
	
	State accept{ 
		println("waitermind 		|| accept")
		updateResource [# "accept" #]
		
//		//TEST
//		println("waitermind 	|| wait Enter - doing accept || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
//		[# readLine() #]
//		//TEST
					
		replyTo smartbellEntryRequest with smartbellEntryReply : smartbellEntryReply(accept, $IdClientOccupy)	
				
	}//end accept
	Goto	reachDoor
	
	State reachDoor{
		println("waitermind 		|| reachDoor") 
		updateResource [# "reachDoor" #] 
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(reachDoor)
		
//		//TEST
//		println("waitermind 	|| wait Enter - doing reachDoor || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
//		[# readLine() #]
//		//TEST

		solve(pos(entrance, X, Y))
			ifSolved{
				[#
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             } 
		
	}//end reachDoor
	Transition t3	whenMsg done -> convoyTable
	
	State convoyTable{
		//TEST
		updateResource [#""+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY()#]
		println("waitermind 		|| wait Enter - pos-> EntranceDoor || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
		[# readLine() #]
		//TEST
		
		println("waitermind 		|| convoyTable")
		updateResource [# "convoyTable"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(convoyTable)
		
		delayVar DelayTakeClient	
//		//TEST
//		println("waitermind 	|| wait Enter - doing convoyTable || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
//		[# readLine() #]
//		//TEST
		
		//STATO TAVOLO TO CHANGE
		forward tearoomglobalstate -m occupyTable : occupyTable($TableToOccupy, $IdClientOccupy)
		//Controllare il tavolo libero
		
		solve(pos("table$TableToOccupy", X, Y))		
		ifSolved{
					[#
						MoveX = getCurSol("X").toString().toInt()
	                	MoveY = getCurSol("Y").toString().toInt()
	                #]
	             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
	             }
             
	}//end convoyTable
	Transition t4	whenMsg done -> startTimerTable
	
	State startTimerTable{
		forward maxstaytime -m startTimer : startTimer($TableToOccupy)
	}
	Goto checkQueue
	
	
	State reachTableOrder{ 
		//[# readLine() #]
		forward waiterengine -m stopEngineMove : stopEngineMove(P)
		if [#CleaningON == true #]
		{
			forward waiterengine -m stopCleaningEngine : stopCleaningEngine($TableToClean)
			[#
				CleaningON = false 
				TableToClean = 0
			#]
		}
		println("waitermind 		|| reachTableOrder")
		updateResource [# "reachTableOrder"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(reachTableOrder)
		
		
		
		//check table ordering
		onMsg(clientOrderReady : clientOrderReady(ID) )
		{
			println("waitermind 		|| client pronto per ordinare ID : ${payloadArg(0)}")
			[#
				IdForOrder = payloadArg(0).toInt()
			#]
		}
		//***********
		request tearoomglobalstate -m getTableFromIdReq : getTableFromIdReq($IdForOrder)
		
//		request waiterengine -m moveTo : moveTo($X_table_1, $Y_table_1)
		
	}//end reachTableOrder
	Transition t5	whenReply getTableFromIdReply -> checkClientPresentInRoomOrder
	
	State checkClientPresentInRoomOrder{
		onMsg (getTableFromIdReply : getTableFromIdReply(N)){
			[#
				TableForOrder = payloadArg(0)	
			#]
			
		}
		if [# TableForOrder == "0"#]{
			[# IdForOrder = 0 #]	
		}
		 
	}
	Goto checkQueue if [# TableForOrder == "0"#] else moveReachTableOrder
	
	State moveReachTableOrder{
		
		forward maxstaytime -m stopTimer : stopTimer($TableForOrder)
		
		solve(pos("table$TableForOrder", X, Y))
			ifSolved{
				[#
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             } 
	} 
	Transition t5	whenMsg done -> waitOrderClient

	State waitOrderClient{ 
		
		//TEST
		updateResource [#""+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY()#]
		println("waitermind 		|| wait Enter - pos-> Tavolo || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
		[# readLine() #]
		//TEST
		
		println("waitermind 		|| waitOrderClient")
		updateResource [# "waitOrderClient" #]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(waitOrderClient)
		
	}
	Transition t6	whenMsg clientOrder -> trasmit
	
	State trasmit {
		//[# readLine() #]
		println("waitermind 		|| trasmit")
		updateResource [# "trasmit"#]	
		onMsg(clientOrder : clientOrder(ID, ORDER)){
			println("waitermind 		|| ricevuto ordine ID,ORDER: ${payloadArg(0)},${payloadArg(1)} ")
			if [# IdForOrder == payloadArg(0).toInt() #]{
				forward barman -m waiterOrderForward : waiterOrderForward($payloadArg(0), $payloadArg(1))
				[#
					IdForOrder = 0
					TableForOrder = "0"	
				#]
			}
		}
		
	}// end trasmit
	Transition	t0 	whenTime 100 -> checkQueue
					whenMsg clientOrder -> trasmit
	
	State reachBar{
		//[# readLine() #]
		forward waiterengine -m stopEngineMove : stopEngineMove(P)
		if [#CleaningON == true #]{
			forward waiterengine -m stopCleaningEngine : stopCleaningEngine($TableToClean)
			[#
				CleaningON = false 
				TableToClean = 0
			#]
		}
		println("waitermind 		|| reachBar")
		updateResource [# "reachBar"#]	
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(reachBar)
		
		
		
		onMsg(barmanOrderReady : barmanOrderReady(ID)){
			println("waitermind 		|| order ready client ID: ${payloadArg(0)}")
			[#
				IdForOrder = payloadArg(0).toInt()
			#]
		}
		solve(pos(bar, X, Y))
			ifSolved{
				[#
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             } 
	}//end reachBar
	Transition t6	whenMsg done -> getDrink
	
	State getDrink{
		//TEST
		updateResource [#""+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY()#]
		println("waitermind 		|| wait Enter - pos-> BARMAN || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
		[# readLine() #]
		//TEST
		println("waitermind 		|| getDrink")
		updateResource [# "getDrink"#]	
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(getDrink)
		forward tearoomglobalstate -m removeOrderReady : removeOrderReady($IdForOrder)
		request tearoomglobalstate -m getTableFromIdReq : getTableFromIdReq($IdForOrder)
		delayVar DelayTakeDrink
		 
			
	}//end getDrink
	Transition t7	whenReply getTableFromIdReply -> checkClientPresentInRoomServe
	
	State checkClientPresentInRoomServe{
		onMsg (getTableFromIdReply : getTableFromIdReply(N)){
			[#
				TableForOrder = payloadArg(0)	
			#]
			
		}
		if [# TableForOrder == "0"#]{
			[# IdForOrder = 0 #]	
		}
		 
	}
	Goto checkQueue if [# TableForOrder == "0"#] else reachTableServe
	
	State reachTableServe{
		println("waitermind 		|| reachTableServe")
		
		solve(pos("table$TableForOrder", X, Y))
			ifSolved{
				[#
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             } 
	}
	Transition t0 whenMsg done -> serveDrinkTable
	
	State serveDrinkTable{
		//per essere realistici
		delayVar DelayServeDrink
		
		forward maxstaytime -m resumeTimer : resumeTimer($TableForOrder)
		 [#
			IdForOrder = 0
			TableForOrder = "0"	
		 #]	
	}
	Goto checkQueue
	
	State reachTableCollect{
		//[# readLine() #]
		
		forward waiterengine -m stopEngineMove : stopEngineMove(P)
		if [#CleaningON == true #]{
			forward waiterengine -m stopCleaningEngine : stopCleaningEngine($TableToClean)
			[#
				CleaningON = false 
				TableToClean = 0
			#]
		}
		println("waitermind 		|| reachTableCollect")
		updateResource [# "reachTableCollect"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(reachTableCollect)
		
		
		
		onMsg(clientPaymentReady : clientPaymentReady(ID)){
			println("waitermind 		|| client wants to pay ID : ${payloadArg(0)}")
			request tearoomglobalstate -m getTableFromIdReq : 	getTableFromIdReq($payloadArg(0))			
		}
		//guardo il messaggio clientPaymentReady e leggo ID e capisco tavolo
		
		
	}//end reachTableCollect
	Transition t8	whenReply getTableFromIdReply -> checkReachTableCollectID
		
	
	State checkReachTableCollectID{
		onMsg (getTableFromIdReply : getTableFromIdReply(N)){
			[#
				TableForCollect = payloadArg(0)
			#]
		}
		if [# TableForCollect != "0"#]{
				forward maxstaytime -m stopTimer : stopTimer($TableForCollect) 
		}
	}
	Goto checkQueue if [# TableForCollect == "0"#] else moveReachTableCollect	
	
	State moveReachTableCollect{
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(moveReachTableCollect)
	
		solve(pos("table$TableForCollect", X, Y))
		ifSolved{
			[#
				MoveX = getCurSol("X").toString().toInt()
                MoveY = getCurSol("Y").toString().toInt()
             #]
        	forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
        }
	}
	Transition t0	whenMsg done -> collect
	
	State collect{
		//TEST
		updateResource [#""+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY()#]
		println("waitermind 		|| wait Enter - pos-> Tavolo || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
		[# readLine() #]
		//TEST
		
		println("waitermind 		|| collect")
		updateResource [# "collect"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(collect)
		
		//delay time perchè ci metto un po' a prendere il cash
		delayVar CollectTime
	}//end collect
	Goto convoyExit
	 
	State convoyExit{ 
		//[# readLine() #]
		println("waitermind 	|| convoyExit")
		updateResource [# "convoyExit"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(convoyExit)
		
		//STATO DEL TAVOLO DA CAMBIARE
		forward tearoomglobalstate -m setStateTable : setStateTable($TableForCollect,tableDirty,0)
		
		solve(pos(exit, X, Y))
			ifSolved{
				[#
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             }	
		
	}//end convoyExit
	Transition t9 	whenMsg done -> checkQueue
	
	State reachTableClean{
		//TEST
		updateResource [#""+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY()#]
		println("waitermind 		|| wait Enter - pos-> Table || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
		[# readLine() #]
		//TEST
		
		println("waitermind 	|| reachTableClean")
		updateResource [# "reachTableClean"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(reachTableClean)
		
		//cliente deve uscire e devo chiudere la porta
		delay 1000
		//mi muovo verso il tavolo
		
		solve(pos("table$TableToClean", X, Y))
		ifSolved{
			[#
				MoveX = getCurSol("X").toString().toInt()
               	MoveY = getCurSol("Y").toString().toInt()
            #]
            forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
		}
		
	}//end reachTableClear
	Transition t10 	whenMsg done -> whichCleanState
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform
					
	
	
	State whichCleanState{
		if [# TableStateToClean == "tableClearing" || TableStateToClean == "tableDirty" #] {
			forward waitermind -m goToClearing : goToClearing(P)
		}
		if [# TableStateToClean == "tableSanitizing" #] {
			forward waitermind -m goToSanitizing : goToSanitizing(P)
		}
		if [# TableStateToClean == "tableCleaning" #] {
			forward waitermind -m goToCleaning : goToCleaning(P)
		}
	}
	Transition t0	whenMsg goToClearing 	-> tableClearing
					whenMsg goToSanitizing 	-> tableSanitizing
					whenMsg goToCleaning 	-> tableCleaning
	

	State tableClearing{
		//TEST
		updateResource [#""+itunibo.planner.plannerUtil.getPosX()+","+itunibo.planner.plannerUtil.getPosY()#]
		println("waitermind 		|| wait Enter - pos-> Tavolo || (${itunibo.planner.plannerUtil.getPosX()},${itunibo.planner.plannerUtil.getPosY()})" )
		[# readLine() #]
		//TEST
		
		
		updateResource [# "tableClearing"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(tableClearing)
		
		
		forward tearoomglobalstate -m setStateTable : setStateTable($TableToClean,tableClearing,$TableTimerDone)
		
		[# 
			CleaningON = true 
			TableTimerDone = ClearTime-TableTimerDone
		#]
		println("waitermind 	|| tableClearing || $TableTimerDone")
		
		forward waiterengine -m clean : clean($DoClear, $TableTimerDone)
		[#
			TableTimerDone = 0
		#]
	}//end tableClear
	Transition t11	whenMsg doneCleanRun -> tableSanitizing
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform
					
						
	State tableSanitizing{
		//[# readLine() #]
		
		updateResource [# "tableSanitizing"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(tableSanitizing)
		
		forward tearoomglobalstate -m setStateTable : setStateTable($TableToClean,tableSanitizing,$TableTimerDone)
	
		[# 
			CleaningON = true 
			TableTimerDone = SanitizeTime-TableTimerDone
		#]
		println("waitermind 	|| tableSanitizing || $TableTimerDone")
		forward waiterengine -m clean : clean($DoSanitize, $TableTimerDone)
		[#
			TableTimerDone = 0
		#]
	}//end tableSanitize
	Transition t12	whenMsg doneCleanRun -> tableCleaning
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform
	
	
	State tableCleaning{
		//[# readLine() #] 
		
		updateResource [# "tableCleaning"#]
		
		forward tearoomglobalstate -m setWaiterState : setWaiterState(tableCleaning)
		
		forward tearoomglobalstate -m setStateTable : setStateTable($TableToClean,tableCleaning,$TableTimerDone)

		[# 
			CleaningON = true 
			TableTimerDone = CleanTime-TableTimerDone
		#]
		println("waitermind 	|| tableCleaning || $TableTimerDone")
		forward waiterengine -m clean : clean($DoClean, $TableTimerDone)
		[#
			TableTimerDone = 0
		#]
	}//end tableClean
	Transition t12	whenMsg doneCleanRun -> updateTableCleaned
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform
	
	State reachTableKick{
		forward waiterengine -m stopEngineMove : stopEngineMove(P)
		if [#CleaningON == true #]{
			forward waiterengine -m stopCleaningEngine : stopCleaningEngine($TableToClean)
			[#
				CleaningON = false 
				TableToClean = 0
			#]
		}
			
		onMsg ( maxStayTimerExpired : maxStayTimerExpired(N)){
			[#
				TableForCollect = payloadArg(0)
			#]
			println("STO CACCIANDO CLIENTE TAVOLO $TableForCollect")
			solve(pos("table$TableForCollect", X, Y))
			ifSolved{
				[#
					MoveX = getCurSol("X").toString().toInt()
                	MoveY = getCurSol("Y").toString().toInt()
                #]
             forward waiterengine -m moveTo : moveTo($MoveX, $MoveY)	
             }
		}
	}
	Transition t0	whenMsg done -> collect
	
	State updateTableCleaned{
		//[# readLine() #]
		println("waitermind 	|| updateTableCleaned")
		updateResource [# "updateTableCleaned" #]
		
		forward tearoomglobalstate -m setStateTable : setStateTable($TableToClean,tableCleaned,$TableTimerDone)
		
		[# 
			CleaningON = false 	
			TableToClean =  0		
		#]	
		
	}
	Transition t12	whenTime 100			 ->     checkTableToClean
					whenMsg clientOrderReady -> reachTableOrder
					whenMsg clientPaymentReady -> reachTableCollect
					whenMsg barmanOrderReady -> reachBar
					whenMsg maxStayTimerExpired -> reachTableKick
					whenRequest smartbellEntryRequest -> acceptorinform			
	
	
	
	State endState{
		println("waitermind 	|| TERMINATES")
		forward waiterengine -m end : end(V)
		terminate 0
	}//end endState
	
	
	
}
  

 
QActor smartbell context ctxtearoom{
	[# 
		val Temp_max = 40
		var ID_client = 1 
		var ClientTemp :Double = 0.0
	#] 

	State s0 initial{
		println("smartbell 		|| START")
		updateResource [# "START" #]
	} 
	Goto waitRing
	 
	State waitRing{
		println("smartbell 		|| waitRing")
		updateResource [# "waitRing" #]		
	} 
	Transition t0 	whenRequest clientRingEntryRequest -> checkTempClient
					whenMsg end -> endState
					
	State checkTempClient{  
		//[#  var ClientTemp = Math.random()*6+35#] //random temperature
		[# ClientTemp = kotlin.math.round(  (Math.random()*5+35)*10 )/10 #] 
		println("smartbell 		|| checkTempClient")
		updateResource [# "checkTempClient" #]	
		if [# ClientTemp < Temp_max #]  
		{
			println("smartbell 		|| clienteAccettatoDaSmartBell || temperatura = $ClientTemp || id_client = $ID_client")
			request waitermind -m smartbellEntryRequest : smartbellEntryRequest($ID_client)  
			[# ID_client++ #]
		}
		else
		{
			println("smartbell 		|| clienteRifiutatoDaSmartBell || temperatura = $ClientTemp")
			forward smartbell -m smartbellClientRejected : smartbellClientRejected($ClientTemp) //per questione statistica
			
		}
	}  
	Transition t1 	whenReply 	smartbellEntryReply -> checkWaiterReply	
					whenMsg 	smartbellClientRejected -> clientRejected
	
	State checkWaiterReply{
		
		onMsg(smartbellEntryReply : smartbellEntryReply(ENTRATA, ID)){
			println("smartbell 		|| ricevuta reply : ${ payloadArg(0) }")
			if [# payloadArg(0) == "accept"#]
			{
					forward tearoomglobalstate -m addClientAccepted : addClientAccepted(P)
			}
			replyTo clientRingEntryRequest with clientRingEntryReply : clientRingEntryReply($payloadArg(0), $payloadArg(1))
		}
	}
	Goto waitRing
	
	State clientRejected{
		
		forward tearoomglobalstate -m addClientRejected : addClientRejected(P)
		
		onMsg(smartbellClientRejected : smartbellClientRejected(TEMP)){ //rispondo con temperatura (maggior del normale)
			replyTo clientRingEntryRequest with clientRingEntryReply : clientRingEntryReply(rifiutato, $payloadArg(0)) 
		}
	}
	Goto waitRing
	
	State endState{
		println("smartbell 		|| END")
		terminate 0
	}
	
}



QActor waiterengine context ctxtearoom{ 
		[# 
			var StepTime = 430L
			val BackTime     = 2 * StepTime / 3
			
			val mapRoom  = "teaRoomExplored"
			var XPoint = "0"
			var YPoint = "0"
			
			var CmdToPerform = ""  
			
			var TableToStop = 0
		#]
		
	State s0 initial{
		println("waiterengine 		|| START")
		updateResource [# "startState" #]
		
	
		run itunibo.planner.plannerUtil.initAI() 
		run itunibo.planner.plannerUtil.loadRoomMap(mapRoom) 		
		run itunibo.planner.plannerUtil.showCurrentRobotState()	
		
		forward waitermind -m engineReady : engineReady(P)
	}
	Goto waitCmd
	
	
	State waitCmd{
		println("waiterengine 		|| waitCmd")
		updateResource [# "waitCmd" #]
	}
	Transition t0	whenMsg moveTo -> planPath
					whenMsg clean -> cleanTable
					whenMsg stopEngineMove -> waitCmd
	
	
	
	State planPath{
		println("waiterengine 		|| planPath")
		updateResource [# "planPath" #]
		onMsg(moveTo : moveTo(X,Y)){
			[# XPoint = payloadArg(0)
			   YPoint = payloadArg(1)			  
			 #]
			 }
			println("moveTo ($XPoint,$YPoint)")
			run itunibo.planner.plannerUtil.planForGoal("$XPoint","$YPoint")
	}
	Goto readStep
	
	State readStep{
//		println("waiterengine || readStep")
			[#  CmdToPerform = itunibo.planner.plannerUtil.getNextPlannedMove() #]
	}
	Goto execStep if  [# CmdToPerform == "w"#] else execMove
	//funziona? se mi trovo già al punto che succede?
	
	State checkStopEngine{
		
	}
	Transition t0 	whenTime 100 -> readStep
					whenMsg stopEngineMove -> stopEngine
					
	State stopEngine{
		run itunibo.planner.plannerUtil.resetActions()
	}
	Goto waitCmd
	
	State execMove{
//		println("waiterengine || execMove")
		forward basicrobot -m cmd : cmd($CmdToPerform)
		delay 200
	}
	Goto updateMap
	
	
	State endPath{
		println("waiterengine 		|| endPath")
		updateResource [# "endPath" #]
		println("done moveTo($XPoint,$YPoint)")
		//run itunibo.planner.plannerUtil.showCurrentRobotState()
		forward waitermind -m done : done($XPoint,$YPoint)
	}
	Goto waitCmd
	
	State execStep{
//		println("waiterengine || execStep")
		request basicrobot -m step : step($StepTime)
	}
	Transition t1	whenReply stepdone -> updateMap
					whenReply stepfail   -> errorHandler
	
	State updateMap{
		updateResource [# itunibo.planner.plannerUtil.getMapOneLine() #]
		run itunibo.planner.plannerUtil.updateMap("$CmdToPerform")	
		
	}
	Goto checkStopEngine if [# CmdToPerform.length > 0 #] else endPath
	
	State errorHandler{
		println("waiterengine 		|| errorHandler")
		//torno indietro di un po'
		
		onMsg(stepfail : stepfail(DURATION, CAUSE) ){
			[# 
				val D = payloadArg(0).toLong()  
				val Dt = Math.abs(StepTime-D)
				val BackT = D/4 
			#] 
			//println("robotmapper stepFail D= $D, BackTime = ${BackTime} BackT=$BackT")
 			if [# D > BackTime #] {    
				forward basicrobot -m cmd : cmd( s )
				delayVar BackT
				forward basicrobot -m cmd : cmd( h )
			}	
		}	    
	}
	Goto updateMap
	
	

	State cleanTable{
		onMsg(clean : clean(R, TIMER)){
			if [# payloadArg(0) == "1" #] 
			{//sono in clear
				println("waiterengine 		|| clearing")
				forward timercleaning -m startTimerCleaning : startTimerCleaning($payloadArg(1))
			}//else if
			if [# payloadArg(0) == "2" #]
			{
				println("waiterengine 		|| sanitizing")
				forward timercleaning -m startTimerCleaning : startTimerCleaning($payloadArg(1))
			}
			if [# payloadArg(0) == "3" #]
			{
				println("waiterengine 		|| cleaning")
				forward timercleaning -m startTimerCleaning : startTimerCleaning($payloadArg(1))
			} 
		}	
	}
	Transition t0 	whenMsg timerFinishedCorrectly -> informStateAboutEndCleaning
					whenMsg stopCleaningEngine  -> stopTimer
					
	
	State informStateAboutEndCleaning{
		onMsg (stopTimerCleaningReply : stopTimerCleaningReply(TIMERDONE)){
			forward tearoomglobalstate -m setTimerTableStopped : setTimerTableStopped($TableToStop, $payloadArg(0))	
			[# TableToStop  = 0 #]
		}
		onMsg (timerFinishedCorrectly : timerFinishedCorrectly(P)){
			forward waitermind -m doneCleanRun : doneCleanRun(P)
		}
		
	}
	Goto waitCmd
	
	State stopTimer{
		onMsg (stopCleaningEngine : stopCleaningEngine(TAVOLO) ){
			[# TableToStop = payloadArg(0).toInt() #]
		}
		request timercleaning -m stopTimerCleaningReq : stopTimerCleaningReq(P)
	}
	Transition t0	whenReply stopTimerCleaningReply -> informStateAboutEndCleaning
	
}

QActor barman context ctxtearoom{
	[#
		val TimePrepareOrder = 2000L
	#]
	State s0 initial{
		println("barman 	|| START")
		updateResource [# "START" #] 
	}
	Goto waitOrder
	
	State waitOrder{
		println("barman 	|| waitOrder")
		updateResource [# "waitOrder" #]
		
		forward tearoomglobalstate -m setBarmanState : setBarmanState(waitOrder)
		
	}
	Transition t0 	whenMsg waiterOrderForward -> prepareOrder
					whenMsg end -> endState
	
	State prepareOrder{ 
		println("barman 	|| prepareOrder")
		updateResource [# "prepareOrder" #]

		onMsg(waiterOrderForward : waiterOrderForward(ID, ORDER)){
			println("barman 	|| Order:  ${payloadArg(1)}")
			
			forward tearoomglobalstate -m setBarmanState : setBarmanState(prepareOrder( $payloadArg(0), $payloadArg(1) ))
		
			delayVar TimePrepareOrder
			
			forward tearoomglobalstate -m addOrderReady : addOrderReady($payloadArg(0))
			
			forward waitermind -m barmanOrderReady : barmanOrderReady($payloadArg(0))	
		}		
	}
	Goto waitOrder
	
	State endState{
		println("barman 	|| END")
		terminate 0
	}
}

QActor timercleaning context ctxtearoom{
	
	[#
		var TimerTime      = 0L
		var StartTime     = 0L    
		var Duration      = 0L    
	#]  
	State s0 initial{
		println("timercleaning		|| START")
	}
	Goto waitCmd
	
	State waitCmd{
		println("timercleaning		|| waitCmd")
	}
	Transition t0	whenMsg startTimerCleaning -> startTimer
	
	State startTimer{
		println("timercleaning		|| startTimer")
		onMsg(startTimerCleaning : startTimerCleaning(TIMER)){
			[# TimerTime = payloadArg(0).toLong() #]
			println("timer ${payloadArg(0)}")
			memoCurrentTime StartTime
		}
	}
	Transition t1 	whenTimeVar TimerTime -> timeFinished
					whenRequest stopTimerCleaningReq -> stopTimer
					
	State timeFinished{
		forward waiterengine -m timerFinishedCorrectly : timerFinishedCorrectly(P)	
	}
	Goto waitCmd
					
	State stopTimer{
		setDuration Duration from StartTime 
		replyTo stopTimerCleaningReq with stopTimerCleaningReply : stopTimerCleaningReply($Duration)
	}
	Goto waitCmd

}
QActor maxstaytime context ctxtearoom{ 
	State s0 initial{
		println("maxstaytime	|| START")
	}
	Goto waitCmd
	
	State waitCmd{
		println("maxstaytime	|| WaitCmd")
	}
	Transition t0	whenMsg	startTimer -> newTimer
					whenMsg resumeTimer -> resume
					whenMsg stopTimer -> stop
					whenMsg maxStayTimerExpired -> timerExpired
					whenRequest askMaxStayTimeLeftReq -> getTimeLeft
	
	State newTimer{	
		onMsg(startTimer : startTimer(N)){
			if [# payloadArg(0) == "1" #]
			{
				forward maxstaytime1 -m startTimer : startTimer(1)
			}
			if [# payloadArg(0) == "2" #]
			{
				forward maxstaytime2 -m startTimer : startTimer(2)
			}
		}
	}
	Goto waitCmd
	
	State resume{
		onMsg(resumeTimer : resumeTimer(N)){
			if [# payloadArg(0) == "1" #]
			{
				forward maxstaytime1 -m resumeTimer : resumeTimer(1)
			}
			if [# payloadArg(0) == "2" #]
			{
				forward maxstaytime2 -m resumeTimer : resumeTimer(2)
			}
		}	
	}
	Goto waitCmd
	
	State stop{
		onMsg(stopTimer : stopTimer(N)){
			if [# payloadArg(0) == "1" #]
			{
				forward maxstaytime1 -m stopTimer : stopTimer(1)
			}
			if [# payloadArg(0) == "2" #]
			{
				forward maxstaytime2 -m stopTimer : stopTimer(2)
			}
		}
	}
	Goto waitCmd
	
	State timerExpired{
		onMsg(maxStayTimerExpired : maxStayTimerExpired(N)){
			if [# payloadArg(0) == "1" #]
			{
				println("Ex 1")
				updateResource [#"Expired 1"#]
				forward waitermind -m maxStayTimerExpired : maxStayTimerExpired(1)
			}
			if [# payloadArg(0) == "2" #]
			{
				println("Ex 2")
				updateResource [#"Expired 2"#]
				forward waitermind -m maxStayTimerExpired : maxStayTimerExpired(2)
			}
		}
	}
	Goto waitCmd
	
	State getTimeLeft{
		onMsg (askMaxStayTimeLeftReq : askMaxStayTimeLeftReq(N)){
			if [# payloadArg(0) == "1" #]
			{
				request maxstaytime1 -m getMaxStayTimeLeftReq : getMaxStayTimeLeftReq(1) 
			}
			if [# payloadArg(0) == "2" #]
			{
				request maxstaytime2 -m getMaxStayTimeLeftReq : getMaxStayTimeLeftReq(2) 
			}
		}
	}
	Transition t0 whenReply getMaxStayTimeLeftReply -> analizeReplyAndForward
	
	State analizeReplyAndForward{
		onMsg(getMaxStayTimeLeftReply : getMaxStayTimeLeftReply(TIMERLEFT)){
			replyTo askMaxStayTimeLeftReq with askMaxStayTimeLeftReply : askMaxStayTimeLeftReply($payloadArg(0))
		}
	}
	Goto waitCmd
}

QActor maxstaytime1 context ctxtearoom{
	[#
		val TimeMaxStay 	= 90000L
		var StartTime 		= 0L	
		var TimerDone 		= 0L
		var TimerGlobalDone = 0L
		var TimeAfterResume = 0L
		var TimerToReturn   = 0L
	#]
	State s0 initial{
		println("maxstaytime1		|| START")
		updateResource [# "start" #] 
	}
	Goto waitCmd
	
	State waitCmd{
		updateResource [# "waitCmd1" #] 
	}
	Transition t0 	whenMsg startTimer -> newTimer
					whenMsg stopTimer -> waitCmd
					whenMsg resumeTimer -> resume
					whenRequest getMaxStayTimeLeftReq -> returnTimerDone
	
	State newTimer{
		memoCurrentTime StartTime
		[# TimerGlobalDone = 0 #]
		updateResource [# "StartTimerCount1" #] 
	}
	Transition t1 	whenTimeVar TimeMaxStay -> timerExpired
					whenMsg		stopTimer	-> stop
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDone	
	
	State returnTimerDone{
		setDuration TimerDone from StartTime
		[# 
			TimerGlobalDone += TimerDone
			TimerToReturn = TimeMaxStay - TimerGlobalDone
		#]
		updateResource [# "TimerDone1 $TimerToReturn " #] 
		replyTo getMaxStayTimeLeftReq with getMaxStayTimeLeftReply : getMaxStayTimeLeftReply($TimerToReturn)
	}
	Goto resume
					
	State stop{
		setDuration TimerDone from StartTime
		[# TimerGlobalDone += TimerDone #]
		updateResource [# "Stop1 $TimerGlobalDone " #] 
	}
	Transition t2	whenMsg		resumeTimer -> resume
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDoneStop	
	
	State returnTimerDoneStop{
		[# 
			TimerToReturn = TimeMaxStay - TimerGlobalDone
		#]
		updateResource [# "Return1 $TimerGlobalDone " #] 
		replyTo getMaxStayTimeLeftReq with getMaxStayTimeLeftReply : getMaxStayTimeLeftReply($TimerToReturn)
	}
	Transition t2	whenMsg		resumeTimer -> resume
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDoneStop	
	
	
	State resume{
		[# TimeAfterResume = TimeMaxStay - TimerGlobalDone #]
		updateResource [# "Resume1 $TimeAfterResume " #] 
		memoCurrentTime StartTime
	}
	Transition t3	whenTimeVar	TimeAfterResume -> timerExpired
					whenMsg		stopTimer	-> stop
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDone	
	
	State timerExpired{
		println("EXPIRED1")
		updateResource [# "TimerExpired1 " #] 
		forward maxstaytime -m maxStayTimerExpired : maxStayTimerExpired(1)
	}
	Goto waitCmd

}

QActor maxstaytime2 context ctxtearoom{
	[#
		val TimeMaxStay 	= 90000L
		var StartTime 		= 0L	
		var TimerDone 		= 0L
		var TimerGlobalDone = 0L
		var TimeAfterResume = 0L
		var TimerToReturn   = 0L
	#]
	State s0 initial{
		println("maxstaytime2		|| START")
		updateResource [# "start" #] 
	}
	Goto waitCmd
	
	State waitCmd{
		updateResource [# "waitCmd2" #] 
	}
	Transition t0 	whenMsg startTimer -> newTimer
					whenMsg stopTimer -> waitCmd
					whenMsg resumeTimer -> resume
					whenRequest getMaxStayTimeLeftReq -> returnTimerDone
	
	State newTimer{
		memoCurrentTime StartTime
		[# 
			TimerGlobalDone = 0 
		#]
//			TimerAfterResume = 0
//			TimerToReturn = 0
//			TimerDone = 0
//			StartTime = 0
		updateResource [# "StartTimerCount2" #] 
	}
	Transition t1 	whenTimeVar TimeMaxStay -> timerExpired
					whenMsg		stopTimer	-> stop
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDone	
	
	State returnTimerDone{
		setDuration TimerDone from StartTime
		[# 
			TimerGlobalDone += TimerDone
			TimerToReturn = TimeMaxStay - TimerGlobalDone
		#]
		updateResource [# "TimerDone2 $TimerToReturn " #] 
		replyTo getMaxStayTimeLeftReq with getMaxStayTimeLeftReply : getMaxStayTimeLeftReply($TimerToReturn)
	}
	Goto resume
					
	State stop{
		setDuration TimerDone from StartTime
		[# TimerGlobalDone += TimerDone #]
		updateResource [# "Stop2 $TimerGlobalDone " #] 
	}
	Transition t2	whenMsg		resumeTimer -> resume
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDoneStop	
	
	State returnTimerDoneStop{
		[# 
			TimerToReturn = TimeMaxStay - TimerGlobalDone
		#]
		updateResource [# "Return2 $TimerGlobalDone " #] 
		replyTo getMaxStayTimeLeftReq with getMaxStayTimeLeftReply : getMaxStayTimeLeftReply($TimerToReturn)
	}
	Transition t2	whenMsg		resumeTimer -> resume
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDoneStop	
	
	
	State resume{
		[# TimeAfterResume = TimeMaxStay - TimerGlobalDone #]
		updateResource [# "Resume2 $TimeAfterResume " #] 
		memoCurrentTime StartTime
	}
	Transition t3	whenTimeVar	TimeAfterResume -> timerExpired
					whenMsg		stopTimer	-> stop
					whenMsg 	startTimer	-> newTimer
					whenRequest getMaxStayTimeLeftReq -> returnTimerDone	
	
	State timerExpired{
		updateResource [# "TimerExpired2 " #] 
		println("EXPIRED2")
		forward maxstaytime -m maxStayTimerExpired : maxStayTimerExpired(2)
	}
	Goto waitCmd

}



QActor tearoomglobalstate context ctxtearoom{
	
	[#
		val TimeMaxStay 	= 90000L
		val TotalCleaning	= 1600L	
		var TimeLeft1 		= 0L
		var TimeLeft2 		= 0L
		var ToReturnTimer 	= 0L
	#]
	State s0 initial{
		println("tearoomglobalstate		|| START")
		solve( consult("tearoomstate.pl") )
	}
	Goto wait
	
	State wait{
		println("tearoomglobalstate		|| wait")
		[# var StateRoom = "" #]
		solve (statetearoom( waiter(SW), barman(SB),  stateTable(1, ST1, T1), stateTable(2, ST2, T2), clientiAccettati(NA), clientiRifiutati(NR) ))
		ifSolved
		{
			[#
				StateRoom = 
				"Waiter: " + getCurSol("SW").toString() +"\n"+
				"Barman: " + getCurSol("SB").toString() +"\n"+
				"TABLE 1: " + getCurSol("ST1").toString() +", timerDone: "+ getCurSol("T1").toString()+"\n"+
				"TABLE 2: " + getCurSol("ST2").toString() +", timerDone: "+ getCurSol("T2").toString()+"\n"+
				"Client Accepted: " + getCurSol("NA").toString() +"\n"+
				"Client Rejected: " + getCurSol("NR").toString()
			#]
			
		}
		println("***********************") 
		println(StateRoom)
		println("***********************")
		//mancano ORDINI PRONTI
	}
	Transition t0 	whenMsg	setWaiterState	-> waiterState
					whenMsg setBarmanState	-> barmanState
					whenMsg addOrderReady	-> orderReady
					whenMsg removeOrderReady -> orderTaken
					whenMsg addClientAccepted -> clientAccepted
					whenMsg addClientRejected -> clientRejected
					whenMsg setStateTable 	-> stateTable
					whenMsg occupyTable 		-> occupyTableState
					whenMsg setTimerTableStopped -> timerStoppedTable
					whenRequest getTable1StateReq	-> returnTable1State
					whenRequest getTable2StateReq -> returnTable2State
					whenRequest	getTableToCleanReq -> returnTableToClean
					whenRequest	getFreeCleanTableReq -> returnFreeTable
					whenRequest getTableFromIdReq -> returnTableFromId
					whenRequest getTimerForInformReq -> returnTimeInform
					
	State waiterState{
		onMsg (setWaiterState : setWaiterState(STATO)){
			solve(setWaiter($payloadArg(0)))
		}
	}
	Goto wait
	
	State barmanState{
		onMsg (setBarmanState : setBarmanState(STATO)){
			solve(setBarman($payloadArg(0)))
		}
	}
	Goto wait
	
	State orderReady{
		onMsg (addOrderReady : addOrderReady(ID)){
			solve(addOrderReady($payloadArg(0)))
		}
	}
	Goto wait
	
	State orderTaken{
		onMsg (removeOrderReady : removeOrderReady(ID)){
			solve(removeOrderReady($payloadArg(0)))
		}
	}
	Goto wait
	
	State clientAccepted{
		solve(incAccettati)
	}
	Goto wait
	
	State clientRejected{
		solve(incRifiutati)
	}
	Goto wait
	
	State stateTable{
		onMsg (setStateTable : setStateTable(N, STATO, TIMERDONE)){
			solve(setStateTable($payloadArg(0), $payloadArg(1), $payloadArg(2)))
		}
	}
	Goto wait
	
	State occupyTableState{
		onMsg (	occupyTable : occupyTable(N, ID)){
			solve(occupyTable($payloadArg(0), $payloadArg(1)))
		}
	}
	Goto wait
	
	State timerStoppedTable{
		onMsg (setTimerTableStopped : setTimerTableStopped(N, TIMER)){
				solve( stateTable($payloadArg(0), S, T))
				ifSolved
				{
					[#
						var Stato = getCurSol("S").toString()
						var Tempo = getCurSol("T").toString().toLong() + payloadArg(1).toLong()
					#]
					solve( setStateTable ($payloadArg(0), $Stato, $Tempo))
				}	
		}	

	}
	Goto wait
	
	State returnTable1State{
		
	}
	Goto wait
	
	State returnTable2State{
		
	}
	Goto wait
	
	State returnTimeInform{
		[# ToReturnTimer = 0L #]
//		solve ( stateTable(1, S, T))
//		ifSolved
//		{
//			[# var Stato = getCurSol("S").toString() #]
//			if [# Stato == "tableDirty" || Stato == "tableCleaning" || Stato == "tableClearing" || Stato == "tableSanitizing"#]
//			{
//				[# ToReturnTimer = TotalCleaning #] 
//			}
//		}
//		if[# ToReturnTimer == 0L #]
//		{
//			solve ( stateTable(2, S, T))
//			ifSolved
//			{
//				[# var Stato = getCurSol("S").toString() #]
//				if [# Stato == "tableDirty" || Stato == "tableCleaning" || Stato == "tableClearing" || Stato == "tableSanitizing"#]
//				{
//					[# ToReturnTimer = TotalCleaning #] 
//				}
//			}
//		}
//		
//		if[# ToReturnTimer == 0L #]
//		{
//			[# ToReturnTimer = TotalCleaning+TimeMaxStay #]
//		}
//		replyTo getTimerForInformReq with getTimerForInformReply : getTimerForInformReply($ToReturnTimer)
//		
		solve ( stateTable(1, S, T))
		ifSolved
		{
			[# var Stato = getCurSol("S").toString() #]
			if [# Stato == "tableDirty" || Stato == "tableCleaning" || Stato == "tableClearing" || Stato == "tableSanitizing"#]
			{
				[# ToReturnTimer = TotalCleaning #] 
			}
		}
		if[# ToReturnTimer == 0L #]
		{
			solve ( stateTable(2, S, T))
			ifSolved
			{
				[# var Stato = getCurSol("S").toString() #]
				if [# Stato == "tableDirty" || Stato == "tableCleaning" || Stato == "tableClearing" || Stato == "tableSanitizing"#]
				{
					[# ToReturnTimer = TotalCleaning #] 
				}
			}
		}
		
		if[# ToReturnTimer != 0L #]
		{
			replyTo getTimerForInformReq with getTimerForInformReply : getTimerForInformReply($ToReturnTimer)
		}
		
	}
	Goto wait if [# ToReturnTimer != 0L #] else askTimeLeft1
	
	State askTimeLeft1{
		request maxstaytime -m askMaxStayTimeLeftReq : askMaxStayTimeLeftReq(1)	
	}
	Transition t0	whenReply	askMaxStayTimeLeftReply -> askTimeLeft2
	 
	State askTimeLeft2{
		onMsg(askMaxStayTimeLeftReply : askMaxStayTimeLeftReply(TIMERLEFT)){
			[# TimeLeft1 = payloadArg(0).toLong()#]
		}
		request maxstaytime -m askMaxStayTimeLeftReq : askMaxStayTimeLeftReq(2)	
	}
	Transition t0	whenReply	askMaxStayTimeLeftReply -> respondForInform
	
	State respondForInform{
		[# ToReturnTimer = 0L #]
		onMsg(askMaxStayTimeLeftReply : askMaxStayTimeLeftReply(TIMERLEFT)){
			[# TimeLeft2 = payloadArg(0).toLong()#]
		}
		[# ToReturnTimer = TotalCleaning #] 
		if[# TimeLeft1 < TimeLeft2 #]
		{
			[# ToReturnTimer += TimeLeft1 #] 
		}
		else 
		{
			[# ToReturnTimer += TimeLeft2 #] 
		}
		replyTo getTimerForInformReq with getTimerForInformReply : getTimerForInformReply($ToReturnTimer)
	}
	Goto wait
	
	State returnTableToClean{
		[#
			var ToReturn = 0
			var Stato1String = ""
			var Stato2String = ""
			var Stato1 = 0
			var Stato2 = 0	
			var Tempo1 = 0
			var Tempo2 = 0
		#]
		solve( stateTable(1, S, T))
		ifSolved
		{
			[#
				Stato1String = getCurSol("S").toString()
				if (Stato1String == "tableDirty") Stato1 = 1
				else if (Stato1String == "tableClearing") Stato1 = 2
				else if (Stato1String == "tableSanitizing") Stato1 = 3
				else if (Stato1String == "tableCleaning") Stato1 = 4
				Tempo1 = getCurSol("T").toString().toInt()
			#]
		}
		solve( stateTable(2, S, T))
		ifSolved
		{
			[#
				Stato2String = getCurSol("S").toString()
				if (Stato2String == "tableDirty") Stato2 = 1
				else if (Stato2String == "tableClearing") Stato2 = 2
				else if (Stato2String == "tableSanitizing") Stato2 = 3
				else if (Stato2String == "tableCleaning") Stato2 = 4
				Tempo2 = getCurSol("T").toString().toInt()
			#]
		}
		[#
			if (Stato1 + Stato2 == 0) ToReturn = 0
			else if( (Stato1 > Stato2) || (Stato1 == Stato2 && Tempo1>=Tempo2)  ) ToReturn = 1
			else ToReturn = 2
		#]
		if [#ToReturn == 0#]{
			replyTo getTableToCleanReq with getTableToCleanReply : getTableToCleanReply(0,0,0)
		} 
		if [#ToReturn == 1#]{
			replyTo getTableToCleanReq with getTableToCleanReply : getTableToCleanReply(1,$Stato1String,$Tempo1)
		}
		if [#ToReturn == 2#]{
			replyTo getTableToCleanReq with getTableToCleanReply : getTableToCleanReply(2,$Stato2String,$Tempo2)
		}
	}
	Goto wait
	
	State returnFreeTable{
		onMsg (getFreeCleanTableReq : getFreeCleanTableReq(P)){
			[#
				var ToReturnFree = 0	
			#]
			solve(stateTable(2, tableCleaned, 0))
			ifSolved
			{
				[#
					ToReturnFree = 2	
				#]
			}
			solve(stateTable(1, tableCleaned, 0))
			ifSolved
			{
				[#
					ToReturnFree = 1	
				#]
			}
			replyTo getFreeCleanTableReq with getFreeCleanTableReply : getFreeCleanTableReply($ToReturnFree)
		}
		
	}
	Goto wait
	
	State returnTableFromId{
		onMsg ( getTableFromIdReq : getTableFromIdReq(ID)){
			[# var Table = "0"#]
			solve( stateTable(N, tableOccupied( $payloadArg(0) ), 0) )
			ifSolved{
				[#
					Table = getCurSol("N").toString()
				#]
			}
			replyTo getTableFromIdReq with getTableFromIdReply : getTableFromIdReply($Table)
		}
	}
	Goto wait
	
	
	
	
}







